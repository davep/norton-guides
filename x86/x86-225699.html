





<!DOCTYPE html>
<html lang="en">

  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <meta name="generator" content="ng2web v1.5.1 (ngdb v1.2.0)">
    <link rel="stylesheet" type="text/css" href="x86-style.css">
    <title>iAPx86 » CPU » Addressing modes</title>
    <meta name="description" content="iAPx86">
    
    
    
  </head>

  <body>

    <header>
      <nav class="box">
        <ul>
          

<li><a href="../index.html">Guides</a></li>


          

<li><a href="x86-about.html">About</a></li>


          

<li><span>Previous</span></li>


          

<li><span>Up</span></li>


          

<li><span>Next</span></li>


        </ul>
      </nav>
    </header>

    <div id="body">

      
        <nav class="menu box">
          <ul>
              <li>CPU</li>
              <li>
                <ul>
                  <li><a href="index.html">Instruction set</a></li>
                  <li><a href="x86-175915.html">Registers</a></li>
                  <li><a href="x86-190707.html">Protection, privilege</a></li>
                  <li><a href="x86-224627.html">Exceptions</a></li>
                  <li><a href="x86-225699.html">Addressing modes</a></li>
                  <li><a href="x86-229455.html">Opcodes</a></li>
                  
                </ul>
              </li>
              <li>FPU</li>
              <li>
                <ul>
                  <li><a href="x86-245307.html">Instruction set</a></li>
                  <li><a href="x86-307843.html">Registers, data types</a></li>
                  
                </ul>
              </li>
              <li>MMX</li>
              <li>
                <ul>
                  <li><a href="x86-318646.html">Instruction set</a></li>
                  
                </ul>
              </li>
          </ul>
        </nav>
      

      <div id="entry" class="box">
        
  
  
    <pre class="entry"><span class="line"></span><br><span class="line"><span class="ngb">Addressing modes</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="ngu">8086+</span></span><br><span class="line"></span><br><span class="line">    <span class="ngb">Base        Index      Displacement</span></span><br><span class="line">    BX or BP    SI or DI   16-bit immediate</span><br><span class="line"></span><br><span class="line">    Default segment is DS; SS if BP is base register.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="ngu">80386+</span> (32-bit addressing only)</span><br><span class="line"></span><br><span class="line">    <span class="ngb">Base                    Index                   Displacement</span></span><br><span class="line">    EAX,ECX,EDX,EBX,        EAX,ECX,EDX,EBX,        32-bit immediate</span><br><span class="line">    ESP,EBP,ESI, or EDI     EBP,ESI, or EDI</span><br><span class="line">                            scaled by 1,2,4, or 8</span><br><span class="line"></span><br><span class="line">    Default segment is DS; SS if EBP or ESP is base register.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Some instructions access memory to fetch or store data; other</span><br><span class="line">    instructions use memory-references to locate the target of a jump</span><br><span class="line">    or procedure call. In either case, the instruction must specify</span><br><span class="line">    the address of the memory location being referenced. The part of</span><br><span class="line">    the instruction that provides the memory location is called the</span><br><span class="line">    address field. The contents of the address field is the <span class="ngb">stated</span></span><br><span class="line">    <span class="ngb">address</span>, and the address of the referenced memory location is</span><br><span class="line">    the <span class="ngb">effective address</span>.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="ngb">Operand-size attribute and address-size attribute</span></span><br><span class="line"></span><br><span class="line">    All instructions operate on either 0, 1, 2, or 3 operands. On the</span><br><span class="line">    80386+, operands can be 8, 16, or 32 bits long. When executing</span><br><span class="line">    16-bit code, they are 8 or 16 bits (<span class="ngb">operand-size attribute</span> 16</span><br><span class="line">    bits); when executing 32-bit code, they are 8 or 32 bits</span><br><span class="line">    (operand-size attribute 32 bits). Prefixes can be added to</span><br><span class="line">    operands to override the default lengths, i.e. use 32-bit operands</span><br><span class="line">    for 16-bit code and vice versa.</span><br><span class="line"></span><br><span class="line">    Memory is accessed with either 16- or 32-bit addresses. Each</span><br><span class="line">    instruction that accesses memory has an <span class="ngb">address-size attribute</span> of</span><br><span class="line">    16 or 32 bits. A 16-bit address both indicates the use of a 16-bit</span><br><span class="line">    displacement in the instruction and an effective address</span><br><span class="line">    calculation; in other words, it means the generation of a 16-bit</span><br><span class="line">    address offset (a segment-relative address). The 32-bit addresses</span><br><span class="line">    use a 32-bit displacement and the generation of a 32-bit address</span><br><span class="line">    offset. Any instruction that reads or writes a 16-bit word or a</span><br><span class="line">    32-bit doubleword has an operand-size attribute of either 16 or 32</span><br><span class="line">    bits.</span><br><span class="line"></span><br><span class="line">    Instructions that implicitly use a stack, such as PUSH EAX, also</span><br><span class="line">    have a <span class="ngb">stack address-size attribute</span> of either 16 or 32 bits. To</span><br><span class="line">    form the address of the top of the stack, the 16-bit addresses use</span><br><span class="line">    the 16-bit SP register. Instructions with a stack address-size</span><br><span class="line">    attribute of 32 bits use the 32-bit ESP register. The stack</span><br><span class="line">    address size attribute is shown by the &#34;D-bit&#34; (B-bit) in the SS</span><br><span class="line">    segment descriptor. If D=0, the stack address-size attribute is 16</span><br><span class="line">    bits; if D=1, the attribute is 32 bits.</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    In protected mode, the processor determines the <span class="ngb">default</span> operand</span><br><span class="line">    size of the instruction it is executing by examining the &#34;D-bit&#34;</span><br><span class="line">    in the CS segment descriptor. If D=0, all operand lengths and</span><br><span class="line">    effective addresses are assumed to be 16 bits long. If D=1, the</span><br><span class="line">    operands and addresses are 32 bits long.</span><br><span class="line">    In real mode and in virtual 8086 mode, the default operand and</span><br><span class="line">    address size is 16 bits (no descriptors in real mode).</span><br><span class="line"></span><br><span class="line">    Regardless of default size, two prefixes (the operand-size prefix</span><br><span class="line">    (66h), and the address-size prefix (67h)) override the D-bit value</span><br><span class="line">    on an individual instruction basis. These prefixes are automatically</span><br><span class="line">    added by assemblers that support the 80386 processor.</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">        <span class="ngb">Examples</span></span><br><span class="line"></span><br><span class="line">        ideal</span><br><span class="line">        p386n</span><br><span class="line">        ; Instruction   Object code generated if ...</span><br><span class="line">        ;               segment _TEXT use16     segment _TEXT use32</span><br><span class="line">        mov  al,[bx]    ; 8A 07                 ; 67 8A 07</span><br><span class="line">        mov  ax,[bx]    ; 8B 07                 ; 66 67 8B 07</span><br><span class="line">        mov  eax,[bx]   ; 66 8B 07              ; 67 8B 07</span><br><span class="line">        mov  al,[ebx]   ; 67 8A 03              ; 8A 03</span><br><span class="line">        mov  ax,[ebx]   ; 67 8B 03              ; 66 8B 03</span><br><span class="line">        mov  eax,[ebx]  ; 66 67 8B 03           ; 8B 03</span><br><span class="line">        push ax         ; 50                    ; 66 50</span><br><span class="line">        push eax        ; 66 50                 ; 50</span><br><span class="line">        pop  edx        ; 66 5A                 ; 5A</span><br><span class="line">        pop  dx         ; 5A                    ; 66 5A</span><br><span class="line">        ; ...</span><br><span class="line">                        ends                    ends</span><br></pre>
  
  
  
    <nav class="seeAlso">
      <ul>
        <li>See Also:</li>
        
          <li>
            
              <a href="x86-76751.html">LEA</a>
            
          </li>
        
          <li>
            
              <a href="x86-197219.html">Descriptors</a>
            
          </li>
        
      </ul>
    </nav>
  


      </div>

    </div>

    
      <footer>
        <nav class="box">
          <dl>
            <dt>Generated</dt><dd>2025-12-13 13:35:14</dd>
            <dt>Generator</dt><dd><a href="https://ng2web.davep.dev">ng2web v1.5.1 (ngdb v1.2.0)</a></dd>
          </dl>
        </nav>
      </footer>
    

  </body>

</html>

