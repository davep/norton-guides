





<!DOCTYPE html>
<html>

  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <meta name="generator" content="ng2web v1.1.0 (ngdb v1.1.0)">
    <link rel="stylesheet" type="text/css" href="dpmi-style.css">
    <title>Dos Protected Mode Interface » DPMI » OverView</title>
    <meta name="description" content="Dos Protected Mode Interface">
    <link rel="prev" href="dpmi-11940.html">
    <link rel="next" href="dpmi-18350.html">
    
  </head>

  <body>

    <header>
      <nav class="box">
        <ul>
          

<li><a href="../index.html">Guides</a></li>


          

<li><a href="dpmi-about.html">About</a></li>


          

<li><a href="dpmi-11940.html">Previous</a></li>


          

<li><a href="index.html">Up</a></li>


          

<li><a href="dpmi-18350.html">Next</a></li>


        </ul>
      </nav>
    </header>

    <section>

      <nav class="menu box">
        <ul>
            <li>DPMI</li>
            <ul>
              <li><a href="index.html">OverView</a></li>
              <li><a href="dpmi-38393.html">DPMI API</a></li>
              
            </ul>
        </ul>
      </nav>

      <article class="box">
        
  
  
    <pre class="entry"><span class="line">        <span class="ngb">Interrupts</span></span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">            Protected mode  programs can hook both hardware and software</span><br /><span class="line">            interrupts  using  the  DPMI  get  and  set  protected  mode</span><br /><span class="line">            interrupt vector functions. All interrupts</span><br /><span class="line">            from  hardware   devices  such  as  the  timer  or  keyboard</span><br /><span class="line">            controller will  always be  reflected to  the protected mode</span><br /><span class="line">            interrupt handler  first.   If the  protected  mode  handler</span><br /><span class="line">            jumps to  or calls  the previous  interrupt handler then the</span><br /><span class="line">            interrupt will be reflected to real mode.</span><br /><span class="line"></span><br /><span class="line">            As in real mode, interrupt procedures can either service the</span><br /><span class="line">            interrupt and  iret or they can chain to the next handler in</span><br /><span class="line">            the interrupt chain by executing pushf/call or by jumping to</span><br /><span class="line">            the next  handler.  The final handler for all protected mode</span><br /><span class="line">            interrupts will reflect the interrupt to real mode.</span><br /><span class="line"></span><br /><span class="line">            When an  interrupt is  reflected to real mode, the EAX, EBX,</span><br /><span class="line">            ECX, EDX,  ESI, EDI,  EBP registers,  and flags  will all be</span><br /><span class="line">            passed from  protected to  real mode unaltered.  The segment</span><br /><span class="line">            registers  will  contain  undefined  values  unless  an  API</span><br /><span class="line">            translator (such  as a  DOS or  BIOS translator)  explicitly</span><br /><span class="line">            sets a  real mode segment register.  DPMI will automatically</span><br /><span class="line">            provide a  real mode stack for interrupts that are reflected</span><br /><span class="line">            to real mode.</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">        <span class="ngu">Hardware Interrupts</span></span><br /><span class="line"></span><br /><span class="line">            The interrupt controllers are mapped to the system&#39;s default</span><br /><span class="line">            interrupts.   On an  IBM AT-compatible  system, for example,</span><br /><span class="line">            the master  interrupt controller  is programmed  with a base</span><br /><span class="line">            interrupt of  8 and  the slave controller has a base of 70h.</span><br /><span class="line">            The virtualized  interrupt controllers  can be reprogrammed;</span><br /><span class="line">            the base  setting may be examined in protected mode with Int</span><br /><span class="line">            31h function 0400h.</span><br /><span class="line"></span><br /><span class="line">            Hardware interrupt  procedures and  all of  their data  must</span><br /><span class="line">            reside in  locked memory.   All  memory that  is touched  by</span><br /><span class="line">            hardware interrupt  hooks must  be locked.  The handler will</span><br /><span class="line">            always be  called on  a locked  stack.</span><br /><span class="line"></span><br /><span class="line">            As in real mode, hardware interrupt handlers are called with</span><br /><span class="line">            interrupts disabled.    Since  iret  will  not  restore  the</span><br /><span class="line">            interrupt flag, hardware interrupt hooks must execute an sti</span><br /><span class="line">            before  executing   iret  or  else  interrupts  will  remain</span><br /><span class="line">            disabled.</span><br /><span class="line"></span><br /><span class="line">            Protected mode  hardware interrupt  handlers will  always be</span><br /><span class="line">            called even  for interrupts  that occur  in real  mode.  The</span><br /><span class="line">            last hook on the protected mode interrupt chain will reflect</span><br /><span class="line">            the interrupt to real mode.</span><br /><span class="line"></span><br /><span class="line">            Protected mode hardware interrupt handlers that need to call</span><br /><span class="line">            software running  in real  mode must either be sure that the</span><br /><span class="line">            real mode  software that  they are  calling will  not modify</span><br /><span class="line">            segment registers  or they  must use  the state save service</span><br /><span class="line">            to  save and  restore the  real mode  segment</span><br /><span class="line">            registers.   However, any  interrupt handler  that  executes</span><br /><span class="line">            completely in  protected mode,  or uses translation services</span><br /><span class="line">            0300h, 0301h,  or 0302h  does not need to save the real mode</span><br /><span class="line">            register state.   Therefore,  this is  not an issue for most</span><br /><span class="line">            interrupt handlers.</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">            For compatibility  with older  systems, computers  with  two</span><br /><span class="line">            interrupt controllers  have the  BIOS redirect  one  of  the</span><br /><span class="line">            interrupts from  the slave  controller into the range of the</span><br /><span class="line">            master controller.   For example, devices jumpered for IRQ 2</span><br /><span class="line">            on IBM  AT-compatible computers  actually interrupt on IRQ 9</span><br /><span class="line">            (interrupt 71h).   In  real mode,  the BIOS on these systems</span><br /><span class="line">            will convert  interrupt 71h  to Int  0Ah and  EOI the  slave</span><br /><span class="line">            controller.   A protected  mode program that needs access to</span><br /><span class="line">            the redirected  interrupt may  use variations  on either  of</span><br /><span class="line">            these techniques:</span><br /><span class="line"></span><br /><span class="line">                 1.   Hook the  target interrupt  in real  mode.    This</span><br /><span class="line">                      takes advantage of the built in redirection.  This</span><br /><span class="line">                      is robust  on systems  where  other  software  has</span><br /><span class="line">                      reprogrammed the  interrupt controllers,  or where</span><br /><span class="line">                      the slave interrupt controller may be absent.</span><br /><span class="line"></span><br /><span class="line">                 2.   Hook  the   actual  interrupt  in  both  real  and</span><br /><span class="line">                      protected mode.   In  this case,  the program must</span><br /><span class="line">                      EOI  both   the   slave   and   master   interrupt</span><br /><span class="line">                      controllers since  the BIOS  will not get control.</span><br /><span class="line">                      This is  more efficient  in that there will not be</span><br /><span class="line">                      any unnecessary switches to real mode.</span><br /><span class="line"></span><br /><span class="line">        <span class="ngu">Software Interrupts</span></span><br /><span class="line"></span><br /><span class="line">            Most software  interrupts executed  in real mode will not be</span><br /><span class="line">            reflected to  the protected  mode interrupt hooks.  However,</span><br /><span class="line">            some software  interrupts are  also reflected  to  protected</span><br /><span class="line">            mode programs when they are called in real mode.  These are:</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">                       INT            DESCRIPTION</span><br /><span class="line"></span><br /><span class="line">                       1Ch    BIOS timer tick interrupt</span><br /><span class="line">                       23h    DOS Ctrl+C interrupt</span><br /><span class="line">                       24h    DOS critical error interrupt</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">            Programs should  not terminate  during interrupts  that were</span><br /><span class="line">            reflected from  real mode.   Terminating the program at this</span><br /><span class="line">            point may prevent the DPMI host from cleaning up properly.</span><br /><span class="line"></span><br /><span class="line">            Of all software interrupts, only Ints 00h-07h will be called</span><br /><span class="line">            with virtual interrupts disabled.  For these interrupts, the</span><br /><span class="line">            handler should  return with  interrupts enabled.   All other</span><br /><span class="line">            interrupts will not modify the interrupt flag state.</span><br /><span class="line"></span><br /><span class="line">            Since most  software interrupts  that are  executed in  real</span><br /><span class="line">            mode are  not reflected  to protected  mode interrupt hooks,</span><br /><span class="line">            programs would  be required to install a real mode interrupt</span><br /><span class="line">            hook to monitor these interrupts.</span><br /></pre>
  
  
  


      </article>

    </section>

  </body>

</html>

