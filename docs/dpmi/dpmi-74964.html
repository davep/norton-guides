





<!DOCTYPE html>
<html>

  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <meta name="generator" content="ng2web v1.1.0 (ngdb v1.1.0)">
    <link rel="stylesheet" type="text/css" href="dpmi-style.css">
    <title>Dos Protected Mode Interface » DPMI » DPMI API</title>
    <meta name="description" content="Dos Protected Mode Interface">
    <link rel="prev" href="dpmi-73024.html">
    <link rel="next" href="dpmi-80802.html">
    
  </head>

  <body>

    <header>
      <nav class="box">
        <ul>
          

<li><a href="dpmi-about.html">About</a></li>


          

<li><a href="dpmi-73024.html">Previous</a></li>


          

<li><a href="dpmi-38393.html">Up</a></li>


          

<li><a href="dpmi-80802.html">Next</a></li>


        </ul>
      </nav>
    </header>

    <section>

      <nav class="menu box">
        <ul>
            <li>DPMI</li>
            <ul>
              <li><a href="index.html">OverView</a></li>
              <li><a href="dpmi-38393.html">DPMI API</a></li>
              
            </ul>
        </ul>
      </nav>

      <article class="box">
        
  
  
    <pre class="entry"><span class="line">        <span class="ngb">Allocate Real Mode Call-Back Address</span></span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">                 This service  is used  to obtain  a  unique  real  mode</span><br /><span class="line">                 SEG:OFFSET that will transfer control from real mode to</span><br /><span class="line">                 a protected mode procedure.</span><br /><span class="line"></span><br /><span class="line">                 At times  it is necessary to hook a real mode interrupt</span><br /><span class="line">                 or device  call-back in  a protected  mode driver.  For</span><br /><span class="line">                 example, many  mouse drivers  call an  address whenever</span><br /><span class="line">                 the mouse is moved.  Software running in protected mode</span><br /><span class="line">                 can use  a real  mode call-back  to intercept the mouse</span><br /><span class="line">                 driver calls.</span><br /><span class="line"></span><br /><span class="line">            To Call</span><br /><span class="line"></span><br /><span class="line">                 AX = 0303h</span><br /><span class="line">                 DS:(E)SI = Selector:Offset of procedure to call</span><br /><span class="line">                 ES:(E)DI = Selector:Offset of real mode call structure</span><br /><span class="line"></span><br /><span class="line">            Returns</span><br /><span class="line"></span><br /><span class="line">                 If function was successful:</span><br /><span class="line">                 Carry flag is clear.</span><br /><span class="line">                 CX:DX = Segment:Offset of real mode call address</span><br /><span class="line"></span><br /><span class="line">                 If function was not successful:</span><br /><span class="line">                 Carry flag is set.</span><br /><span class="line"></span><br /><span class="line">            Call-Back Procedure Parameters</span><br /><span class="line"></span><br /><span class="line">                 Interrupts disabled</span><br /><span class="line">                 DS:(E)SI = Selector:Offset of real mode SS:SP</span><br /><span class="line">                 ES:(E)DI = Selector:Offset of real mode call structure</span><br /><span class="line">                 SS:(E)SP = Locked protected mode API stack</span><br /><span class="line">                 All other registers undefined</span><br /><span class="line"></span><br /><span class="line">            Return from Call-Back Procedure</span><br /><span class="line"></span><br /><span class="line">                 Execute an IRET to return</span><br /><span class="line">                 ES:(E)DI =  Selector:Offset of real mode call structure</span><br /><span class="line">                      to restore (see note)</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">            Programmer&#39;s Notes</span><br /><span class="line"></span><br /><span class="line">                 o    Since the  real mode call structure is static, you</span><br /><span class="line">                      must be  careful when  writing code  that  may  be</span><br /><span class="line">                      reentered.     The  simplest  method  of  avoiding</span><br /><span class="line">                      reentrancy  is   to  leave   interrupts   disabled</span><br /><span class="line">                      throughout the  entire  call.    However,  if  the</span><br /><span class="line">                      amount of  code executed by the call-back is large</span><br /><span class="line">                      then you  will need  to copy  the real  mode  call</span><br /><span class="line">                      structure into  another  buffer.    You  can  then</span><br /><span class="line">                      return with  ES:(E)DI pointing  to the  buffer you</span><br /><span class="line">                      copied the data to -- it does not have to point to</span><br /><span class="line">                      the original real mode call structure.</span><br /><span class="line">                 o    The called  procedure is responsible for modifying</span><br /><span class="line">                      the real mode CS:IP before returning.  If the real</span><br /><span class="line">                      mode CS:IP  is left  unchanged then  the real mode</span><br /><span class="line">                      call-back will  be executed  immediately and  your</span><br /><span class="line">                      procedure will be called again.  Normally you will</span><br /><span class="line">                      want to  pop a return address off of the real mode</span><br /><span class="line">                      stack and  place it  in the  real mode CS:IP.  The</span><br /><span class="line">                      example code  in  the  next  section  demonstrates</span><br /><span class="line">                      chaining  to   another   interrupt   handler   and</span><br /><span class="line">                      simulating a real mode iret.</span><br /><span class="line">                 o    To return  values to the real mode caller you must</span><br /><span class="line">                      modify the real mode call structure.</span><br /><span class="line">                 o    Remember that  all segment values in the real mode</span><br /><span class="line">                      call structure  will contain  real mode  segments,</span><br /><span class="line">                      not selectors.    If  you  need  to  examine  data</span><br /><span class="line">                      pointed to  by a  real mode seg:offset pointer you</span><br /><span class="line">                      should not  use the segment to selector service to</span><br /><span class="line">                      create  a  new  selector.    Instead,  allocate  a</span><br /><span class="line">                      descriptor during  initialization and  change  the</span><br /><span class="line">                      descriptor&#39;s  base  to  16  times  the  real  mode</span><br /><span class="line">                      segment&#39;s  value.     This   is  important   since</span><br /><span class="line">                      selectors allocated though the segment to selector</span><br /><span class="line">                      service can never be freed.</span><br /><span class="line">                 o    DPMI hosts  should provide  a minimum  of 16 call-</span><br /><span class="line">                      back addresses per task.</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">            Example Code</span><br /><span class="line"></span><br /><span class="line">                 The following code is a sample of a real mode interrupt</span><br /><span class="line">                 hook.   It hooks  the DOS  Int 21h and returns an error</span><br /><span class="line">                 for the delete file function (AH=41h).  Other calls are</span><br /><span class="line">                 passed through  to DOS.  This example is somewhat silly</span><br /><span class="line">                 but it  demonstrates the techniques used to hook a real</span><br /><span class="line">                 mode  interrupt.     Note  that  since  DOS  calls  are</span><br /><span class="line">                 reflected  from   protected  mode  to  real  mode,  the</span><br /><span class="line">                 following code  will intercept  all DOS calls from both</span><br /><span class="line">                 real mode and protected mode.</span><br /><span class="line"></span><br /><span class="line">                 ;******************************************************</span><br /><span class="line">                 ; This procedure gets the current Int 21h real mode</span><br /><span class="line">                 ; Seg:Offset, allocates a real mode call-back address,</span><br /><span class="line">                 ; and sets the real mode Int 21h vector to the call-</span><br /><span class="line">                 ; back address.</span><br /><span class="line">                 ;******************************************************</span><br /><span class="line">                 Initialization_Code:</span><br /><span class="line">                 ;</span><br /><span class="line">                 ; Create a code segment alias to save data in</span><br /><span class="line">                 ;</span><br /><span class="line">                         mov     ax, 000Ah</span><br /><span class="line">                         mov     bx, cs</span><br /><span class="line">                         int     31h</span><br /><span class="line">                         jc      ERROR</span><br /><span class="line">                         mov     ds, ax</span><br /><span class="line">                         ASSUMES DS,_TEXT</span><br /><span class="line">                 ;</span><br /><span class="line">                 ; Get current Int 21h real mode SEG:OFFSET</span><br /><span class="line">                 ;</span><br /><span class="line">                         mov     ax, 0200h</span><br /><span class="line">                         mov     bl, 21h</span><br /><span class="line">                         int     31h</span><br /><span class="line">                         jc      ERROR</span><br /><span class="line">                         mov     [Orig_Real_Seg], cx</span><br /><span class="line">                         mov     [Orig_Real_Offset], dx</span><br /><span class="line">                 ;</span><br /><span class="line">                 ; Allocate a real mode call-back</span><br /><span class="line">                 ;</span><br /><span class="line">                         mov     ax, 0303h</span><br /><span class="line">                         push    ds</span><br /><span class="line">                         mov     bx, cs</span><br /><span class="line">                         mov     ds, bx</span><br /><span class="line">                         mov     si, OFFSET My_Int_21_Hook</span><br /><span class="line">                         pop     es</span><br /><span class="line">                         mov     di, OFFSET My_Real_Mode_Call_Struc</span><br /><span class="line">                         int     31h</span><br /><span class="line">                         jc      ERROR</span><br /><span class="line">                 ;</span><br /><span class="line">                 ; Hook real mode int 21h with the call-back address</span><br /><span class="line">                 ;</span><br /><span class="line">                         mov     ax, 0201h</span><br /><span class="line">                         mov     bl, 21h</span><br /><span class="line">                         int     31h</span><br /><span class="line">                         jc      ERROR</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">                 ;******************************************************</span><br /><span class="line">                 ;</span><br /><span class="line">                 ; This is the actual Int 21h hook code.  It will return</span><br /><span class="line">                 ; an &#34;access denied&#34; error for all calls made in real</span><br /><span class="line">                 ; mode to delete a file.  Other calls will be passed</span><br /><span class="line">                 ; through to DOS.</span><br /><span class="line">                 ;</span><br /><span class="line">                 ; ENTRY:</span><br /><span class="line">                 ;    DS:SI -&gt; Real mode SS:SP</span><br /><span class="line">                 ;    ES:DI -&gt; Real mode call structure</span><br /><span class="line">                 ;    Interrupts disabled</span><br /><span class="line">                 ;</span><br /><span class="line">                 ; EXIT:</span><br /><span class="line">                 ;    ES:DI -&gt; Real mode call structure</span><br /><span class="line">                 ;</span><br /><span class="line">                 ;******************************************************</span><br /><span class="line"></span><br /><span class="line">                 My_Int_21_Hook:</span><br /><span class="line">                         cmp     es:[di.RealMode_AH], 41h</span><br /><span class="line">                         jne     Chain_To_DOS</span><br /><span class="line">                 ;</span><br /><span class="line">                 ; This is a delete file call (AH=41h).  Simulate an</span><br /><span class="line">                 ; iret on the real mode stack, set the real mode</span><br /><span class="line">                 ; carry flag, and set the real mode AX to 5 to indicate</span><br /><span class="line">                 ; an access denied error.</span><br /><span class="line">                 ;</span><br /><span class="line">                         cld</span><br /><span class="line">                         lodsw                   ; Get real mode ret IP</span><br /><span class="line">                         mov     es:[di.RealMode_IP], ax</span><br /><span class="line">                         lodsw                   ; Get real mode ret CS</span><br /><span class="line">                         mov     es:[di.RealMode_CS], ax</span><br /><span class="line">                         lodsw                   ; Get real mode flags</span><br /><span class="line">                         or      ax, 1           ; Set carry flag</span><br /><span class="line">                         mov     es:[di.RealMode_Flags], ax</span><br /><span class="line">                         add     es:[di.RealMode_SP], 6</span><br /><span class="line">                         mov     es:[di.RealMode_AX], 5</span><br /><span class="line">                         jmp     My_Hook_Exit</span><br /><span class="line">                 ;</span><br /><span class="line">                 ; Chain to original Int 21h vector by replacing the</span><br /><span class="line">                 ; real mode CS:IP with the original Seg:Offset.</span><br /><span class="line">                 ;</span><br /><span class="line">                 Chain_To_DOS:</span><br /><span class="line">                         mov     ax, cs:[Orig_Real_Seg]</span><br /><span class="line">                         mov     es:[di.RealMode_CS], ax</span><br /><span class="line">                         mov     ax, cs:[Orig_Real_Offset]</span><br /><span class="line">                         mov     es:[di.RealMode_IP], ax</span><br /><span class="line"></span><br /><span class="line">                 My_Hook_Exit:</span><br /><span class="line">                         iret</span><br /></pre>
  
  
  


      </article>

    </section>

  </body>

</html>

