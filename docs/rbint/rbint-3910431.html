





<!DOCTYPE html>
<html>

  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <meta name="generator" content="ng2web v1.1.0 (ngdb v1.1.0)">
    <link rel="stylesheet" type="text/css" href="rbint-style.css">
    <title>Ralf Brown » Lists » Interrupts</title>
    <meta name="description" content="Ralf Brown">
    <link rel="prev" href="rbint-3904447.html">
    <link rel="next" href="rbint-3913822.html">
    
  </head>

  <body>

    <header>
      <nav class="box">
        <ul>
          

<li><a href="rbint-about.html">About</a></li>


          

<li><a href="rbint-3904447.html">Previous</a></li>


          

<li><a href="rbint-3870311.html">Up</a></li>


          

<li><a href="rbint-3913822.html">Next</a></li>


        </ul>
      </nav>
    </header>

    <section>

      <nav class="menu box">
        <ul>
            <li>Lists</li>
            <ul>
              <li><a href="index.html">Comments</a></li>
              <li><a href="rbint-7995.html">Interrupts</a></li>
              <li><a href="rbint-15401.html">Glossary</a></li>
              <li><a href="rbint-64347.html">Memory</a></li>
              <li><a href="rbint-180090.html">CMOS</a></li>
              <li><a href="rbint-250757.html">86 Bugs</a></li>
              
            </ul>
        </ul>
      </nav>

      <article class="box">
        
  
  
    <pre class="entry"><span class="line"></span><br /><span class="line"><span class="ngu">Int 2F Fn 2780  U - Novell Dos 7 - Emm386.exe - Multitasking Api - Memory</span>  [<span class="ngb">m</span>]</span><br /><span class="line"></span><br /><span class="line">   AX = 2780h</span><br /><span class="line">   CL = 03h (module: Memory)</span><br /><span class="line">   CH = subfunction</span><br /><span class="line">       00h ???</span><br /><span class="line">       01h &#34;F_PdirGet&#34; ???</span><br /><span class="line">       02h &#34;F_PdirSet&#34; ???</span><br /><span class="line">       03h &#34;Z_PageAlloc&#34; allocate a given page of memory</span><br /><span class="line">       04h &#34;F_PageAllocG&#34; allocate global page???</span><br /><span class="line">       05h &#34;F_PageAllocI&#34; allocate instance page???</span><br /><span class="line">       06h &#34;F_PtblRead&#34; get page table???</span><br /><span class="line">       07h &#34;F_PtrlWrite&#34; select page table???</span><br /><span class="line">       08h &#34;Z_PtblGet&#34; read page table</span><br /><span class="line">       09h &#34;Z_PtblSet&#34; change page table</span><br /><span class="line">       0Ah &#34;Z_PagesAlloc&#34; allocate pages of memory</span><br /><span class="line">       0Bh &#34;Z_PageFree&#34; free a given page of memory</span><br /><span class="line">       0Ch &#34;Z_MemAlloc&#34; allocate a memory block</span><br /><span class="line">       0Dh &#34;Z_MemFree&#34; release memory block</span><br /><span class="line">       0Eh &#34;Z_MemSizeGet&#34; get size of memory block</span><br /><span class="line">       0Fh &#34;Z_MemResize&#34; resize a memory block</span><br /><span class="line">       10h &#34;Z_DescAlloc&#34; allocate a memory descriptor</span><br /><span class="line">       11h &#34;Z_DescFree&#34; release a memory descriptor</span><br /><span class="line">       12h &#34;Z_DescGet&#34; get details on memory descriptor</span><br /><span class="line">       13h &#34;Z_DescSet&#34; set a memory descriptor</span><br /><span class="line">       14h &#34;Z_MemDescAlloc&#34; allocate a memory block and its descriptor</span><br /><span class="line">       15h &#34;Z_MemDescFree&#34; release a memory block and its descriptor</span><br /><span class="line">       16h &#34;Z_MemDescSizeGet&#34; get size of memory block</span><br /><span class="line">       17h &#34;Z_MemDescResize&#34; resize a memory block</span><br /><span class="line">       18h &#34;Z_PageLock&#34; lock a page, with existing contents</span><br /><span class="line">       19h &#34;Z_PageUnlock&#34; unlock a page</span><br /><span class="line">       1Ah &#34;Z_PageLockAny&#34; lock a page, contents undefined</span><br /><span class="line">       1Bh &#34;Z_PageUnlockReuse&#34; unlock page, reuse phsyical memory</span><br /><span class="line">       1Ch &#34;Z_PageLockNone&#34; lock a page, no physical memory assigned</span><br /><span class="line">       1Dh &#34;Z_PageUnlockNone&#34; unlock a page, don&#39;t reuse physical memory</span><br /><span class="line">       1Eh &#34;F_CallRealRaw&#34; call real mode (SS:ESP supplied)</span><br /><span class="line">       1Fh &#34;F_IntRealRaw&#34; perform real-mode interrupt (SS:ESP supplied)</span><br /><span class="line">       20h &#34;F_CallReal&#34; call real mode with RETF frame</span><br /><span class="line">       21h &#34;F_IntReal&#34; perform real-mode interrupt</span><br /><span class="line">       22h &#34;F_PagedCallReal&#34; paged real-mode call</span><br /><span class="line">       23h &#34;F_PagedIntReal&#34; paged real-mode interrupt</span><br /><span class="line">       24h &#34;F_CallIretReal&#34; call real mode with IRET frame</span><br /><span class="line">       25h &#34;F_CallIretRealRaw&#34; call real mode with IRET (SS:ESP supplied)</span><br /><span class="line">       26h &#34;F_CallProt16&#34; call 16-bit protected-mode code</span><br /><span class="line">       27h &#34;F_CallProt32&#34; call 32-bit protected-mode code</span><br /><span class="line">       28h &#34;F_IAddPage&#34; add kernel instance data</span><br /><span class="line">       29h &#34;Z_PageDomLock&#34; lock page in specific domain, preserve contents</span><br /><span class="line">       2Ah &#34;Z_PatgeDomUnlock&#34; unlock page in specific domain</span><br /><span class="line">       2Bh &#34;Z_PageDomLockAny&#34; lock page in specific domain, undef contents</span><br /><span class="line">       2Ch &#34;Z_PageDomUnlockReuse&#34; unlock page in spec. domain,reuse ph.mem</span><br /><span class="line">       2Dh &#34;Z_PageDomLockNone&#34; lock page in spec. domain, no phys memory</span><br /><span class="line">       2Eh &#34;Z_PageDomUnlockNone&#34; unlock page in spec. domain, no phys. mem</span><br /><span class="line">       2Fh &#34;Z_GateAlloc&#34; allocate a gate</span><br /><span class="line">       30h &#34;Z_GateFree&#34; release a gate</span><br /><span class="line">       31h &#34;X_MemFreeGet&#34; get total free memory</span><br /><span class="line">       32h &#34;X_MemTopGet&#34; get highest memory address</span><br /><span class="line">       33h &#34;X_MemTotalGet&#34; get total memory size</span><br /><span class="line">       34h &#34;F_DescRead&#34; ???</span><br /><span class="line">       35h &#34;F_DescWrite&#34; ???</span><br /><span class="line">       36h &#34;F_GetStack&#34; ???</span><br /><span class="line">       37h &#34;F_SetStack&#34; ???</span><br /><span class="line"></span><br /><span class="line"><span class="ngb">Return:</span> CX = status (most subfunctions)</span><br /><span class="line">   (E)AX and/or (E)BX contain return values, depending on function</span><br /><span class="line"></span><br /><span class="line"><span class="ngb">Notes:</span> called by DPMS.EXE and EMM386.EXE</span><br /><span class="line">   this API is only available if AX=12FFh/BX=0EDCh returns successfully;</span><br /><span class="line">     because the request is handled on the initial trap to the memory</span><br /><span class="line">     manager caused by INT instructions, this API must be invoked with</span><br /><span class="line">     an actual INT 2F instruction instead of some simulation such as a</span><br /><span class="line">     far call to the address in the interrupt vector table</span><br /><span class="line"></span><br /><span class="line"><span class="ngb">See Also:</span> AX=12FFh/BX=0EDCh,AX=2780h/CL=01h,AX=2780h/CL=02h,AX=2780h/CL=04h</span><br /></pre>
  
  
  


      </article>

    </section>

  </body>

</html>

