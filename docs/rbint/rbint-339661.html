





<!DOCTYPE html>
<html>

  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <meta name="generator" content="ng2web v1.1.0 (ngdb v1.1.0)">
    <link rel="stylesheet" type="text/css" href="rbint-style.css">
    <title>Ralf Brown » Lists » 86 Bugs</title>
    <meta name="description" content="Ralf Brown">
    <link rel="prev" href="rbint-339605.html">
    <link rel="next" href="rbint-349920.html">
    
  </head>

  <body>

    <header>
      <nav class="box">
        <ul>
          

<li><a href="rbint-about.html">About</a></li>


          

<li><a href="rbint-339605.html">Previous</a></li>


          

<li><a href="rbint-250757.html">Up</a></li>


          

<li><a href="rbint-349920.html">Next</a></li>


        </ul>
      </nav>
    </header>

    <section>

      <nav class="menu box">
        <ul>
            <li>Lists</li>
            <ul>
              <li><a href="index.html">Comments</a></li>
              <li><a href="rbint-7995.html">Interrupts</a></li>
              <li><a href="rbint-15401.html">Glossary</a></li>
              <li><a href="rbint-64347.html">Memory</a></li>
              <li><a href="rbint-180090.html">CMOS</a></li>
              <li><a href="rbint-250757.html">86 Bugs</a></li>
              
            </ul>
        </ul>
      </nav>

      <article class="box">
        
  
  
    <pre class="entry"><span class="line"></span><br /><span class="line"><span class="ngu">Function:</span></span><br /><span class="line"></span><br /><span class="line">While using a maths coprocessor (also referred to as floating point</span><br /><span class="line">unit FPU), errors may occur and invalid numbers may be generated.</span><br /><span class="line">While most FPUs don&#39;t have any problem handling these situations, some</span><br /><span class="line">steps may lock up or misbehave otherwise. The list below shows known</span><br /><span class="line">malfunctions which may arise during FPU operations on some systems.</span><br /><span class="line"></span><br /><span class="line">    True bugs:</span><br /><span class="line">    &lt;FERR# not handled correctly by FPU&gt;</span><br /><span class="line">    &lt;FPU performance degradation because IGNNE# active&gt;</span><br /><span class="line"></span><br /><span class="line">    Incompatibilities between different types of FPU:</span><br /><span class="line">    &lt;Four indications for &#39;empty&#39; in Condition Code Bits after FXAM&gt;</span><br /><span class="line"></span><br /><span class="line">    &#39;87 to 287 specific differences:</span><br /><span class="line">    &lt;Error signal does not go through PIC on 287+&gt;</span><br /><span class="line">    &lt;Exceptions are different&gt;</span><br /><span class="line">    &lt;Exception pointers saved by 287+ save prefixes&gt;</span><br /><span class="line"></span><br /><span class="line">    &lt;287+ need no synchronization&gt;</span><br /><span class="line">    &lt;287 &amp; 387 use reserved I/O ports&gt;</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">FERR# not handled correctly by FPU</span><br /><span class="line">──────────────────────────────────────────────────────────────────────────────</span><br /><span class="line"> &lt;Back&gt; (General Intel FPU bugs, unrelated to opcodes)</span><br /><span class="line"></span><br /><span class="line">* FERR# not handled correctly by FPU:</span><br /><span class="line"></span><br /><span class="line">    In some cases an FPU operation may generate a floating point error,</span><br /><span class="line">    which will not be recognized by the CPU.</span><br /><span class="line">    The workaround for this is to replace all FWAIT with FNOP or follow</span><br /><span class="line">    all FWAIT with a NOP, while masking all floating point errors.</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">FPU performance degradation because IGNNE# active</span><br /><span class="line">──────────────────────────────────────────────────────────────────────────────</span><br /><span class="line"> &lt;Back&gt; (General Intel FPU bugs, unrelated to opcodes)</span><br /><span class="line"></span><br /><span class="line">* FPU performance degradation because IGNNE# active:</span><br /><span class="line"></span><br /><span class="line">    If an unmasked exception occurs with bit NE (Numeric Error or Numeric</span><br /><span class="line">    Exception) in CR0 cleared (recognize exceptions), while IGNNE# is</span><br /><span class="line">    active, all following FPU instructions will require an additional 17 to</span><br /><span class="line">    22 clocks. This because the exception remains pending due to the logic</span><br /><span class="line">    conflict caused by contradicting signals. It lets the 486/487 execute</span><br /><span class="line">    microcode in order to classify and analyze the exception, but it does</span><br /><span class="line">    not let it handle it, prior to executing the next FPU opcode.</span><br /><span class="line">    A workaround is to clear all unmasked exceptions with FCLEX or FINIT</span><br /><span class="line">    within an exception handler before it finishes or to make sure IGNNE#</span><br /><span class="line">    is not made active so exceptions are recognized and handled immediately</span><br /><span class="line">    as they occur (when NE is cleared).</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">Four indications for &#39;empty&#39; in Condition Code Bits after FXAM</span><br /><span class="line">──────────────────────────────────────────────────────────────────────────────</span><br /><span class="line"> &lt;Back&gt; (General Intel FPU bugs, unrelated to opcodes)</span><br /><span class="line"></span><br /><span class="line">* Four different indications for &#39;empty&#39; in Condition Code Bits after FXAM:</span><br /><span class="line"></span><br /><span class="line">    The various FPUs use different bit patterns to indicate an empty FPU</span><br /><span class="line">    register after the FXAM instruction. You should rely only on bits C0</span><br /><span class="line">    and C3 to be 1 in case an FPU register is to be considered empty.</span><br /><span class="line">    (See &lt;FPU Condition Code Bits&gt;)</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">Error signal does not go through PIC on 287+</span><br /><span class="line">──────────────────────────────────────────────────────────────────────────────</span><br /><span class="line"> &lt;Back&gt; (General Intel FPU bugs, unrelated to opcodes)</span><br /><span class="line"></span><br /><span class="line">* Error signal does not go through PIC on 287+</span><br /><span class="line"></span><br /><span class="line">    On the 86, an FPU error is signalled through the PIC (Programmable</span><br /><span class="line">    Interrupt Controller). Starting with the 287, FPU errors are</span><br /><span class="line">    signalled over a dedicated pin on the CPU / FPU combination,</span><br /><span class="line">    namely ERROR#. There may be code which depends on the PIC handling</span><br /><span class="line">    the error. These error handlers will need to be rewritten.</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">Exceptions are different</span><br /><span class="line">──────────────────────────────────────────────────────────────────────────────</span><br /><span class="line"> &lt;Back&gt; (General Intel FPU bugs, unrelated to opcodes)</span><br /><span class="line"></span><br /><span class="line">* Exceptions are different</span><br /><span class="line"></span><br /><span class="line">    The coprocessor segment overrun exception (09) is issued when the</span><br /><span class="line">    FPU attempts to read the second or subsequent words of a data</span><br /><span class="line">    operand beyond a segment limit on a 286. On a 386 it is not normally</span><br /><span class="line">    used. The 486 signals exception 0dh instead.</span><br /><span class="line"></span><br /><span class="line">    The segment wraparound exception (General Protection exception 0dh)</span><br /><span class="line">    will be issued if the FPU attempts to execute an instruction that</span><br /><span class="line">    spans into or lies beyond a segment limit.</span><br /><span class="line"></span><br /><span class="line">    All other errors are signalled through interrupt 10h in 286 systems.</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">Exception pointers saved by 287+ save prefixes</span><br /><span class="line">──────────────────────────────────────────────────────────────────────────────</span><br /><span class="line"> &lt;Back&gt; (General Intel FPU bugs, unrelated to opcodes)</span><br /><span class="line"></span><br /><span class="line">* Exception pointers saved by 287+ save prefixes</span><br /><span class="line"></span><br /><span class="line">    The exception pointers on the 87 would point to the ESC instruction</span><br /><span class="line">    itself, regardless of any segment overrides (or other prefixes for</span><br /><span class="line">    that matter). The 287+ pointers point to the first prefix before</span><br /><span class="line">    the ESC instruction, if any.</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">287+ need no synchronization</span><br /><span class="line">──────────────────────────────────────────────────────────────────────────────</span><br /><span class="line"> &lt;Back&gt; (General Intel FPU bugs, unrelated to opcodes)</span><br /><span class="line"></span><br /><span class="line">* 287+ need no synchronization</span><br /><span class="line"></span><br /><span class="line">    On the 87, the FPU and CPU worked separated from each other. Any</span><br /><span class="line">    communication between the FPU and CPU had to be coordinated with</span><br /><span class="line">    WAITs. On the 287+, no WAITs are required except for control</span><br /><span class="line">    instructions. The CPU examines the BUSY# signal before communicating</span><br /><span class="line">    with the FPU to assure the FPU can accept commands.</span><br /><span class="line"></span><br /><span class="line">    The 387 also examines BUSY# before sending commands to the FPU.</span><br /><span class="line">    Data transfers are regulated by monitoring the PEREQ# pin.</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">287 &amp; 387 use reserved I/O ports</span><br /><span class="line">──────────────────────────────────────────────────────────────────────────────</span><br /><span class="line"> &lt;Back&gt; (General Intel FPU bugs, unrelated to opcodes)</span><br /><span class="line"></span><br /><span class="line">* 287 &amp; 387 use reserved I/O ports</span><br /><span class="line"></span><br /><span class="line">    On the 287, FPU instructions and data are sent to and received from</span><br /><span class="line">    the FPU via I/O ports. These ports are f0-ff on the 286 / 287.</span><br /><span class="line">    This property is important to consider when the number of I/O</span><br /><span class="line">    waitstates on the mainboard can be changed. To safely increase the</span><br /><span class="line">    FPU performance some experimentation may be necessary, but a 25%</span><br /><span class="line">    speed increase has been accomplished on a 12 MHz 286 with 20 MHz</span><br /><span class="line">    IIT 2c87 by decreasing the number of I/O waitstates from 6 to 4.</span><br /><span class="line"></span><br /><span class="line">    On the 387, FPU instructions and data are sent to and received from</span><br /><span class="line">    the FPU via I/O ports too. These ports are 800000f0 - 800000ff.</span><br /><span class="line">    Note that the I/O waitstate trick may very well work on 386 / 387</span><br /><span class="line">    systems as well.</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">FPU Condition Code Bits after a test, compare or reduction</span><br /><span class="line">──────────────────────────────────────────────────────────────────────────────</span><br /><span class="line"></span><br /><span class="line">Vatious FPU test instructions set the Condition Code bits C0 to C3 based</span><br /><span class="line">on the values tested. Below is a list of possible bit combinations.</span><br /><span class="line"></span><br /><span class="line">These C-bits map to the flags register as follows after stswax and sahf:</span><br /><span class="line"></span><br /><span class="line">Eflags map: ZF  PF  -   CF  (C1 has no flag assigned to it)</span><br /><span class="line">            C3  C2  C1  C0</span><br /><span class="line"></span><br /><span class="line">Examine     0   0   0   0   +Unnormal (positive, valid, unnormalized)</span><br /><span class="line">            0   0   0   1   +NaN      (positive, invalid, exponent is 0)</span><br /><span class="line">            0   0   1   0   -Unnormal (negative, valid, unnormalized)</span><br /><span class="line">            0   0   1   1   -NaN      (negative, invalid, exponent is 0)</span><br /><span class="line">            0   1   0   0   +Normal   (positive, valid, normalized)</span><br /><span class="line">            0   1   0   1   +Infinity (positive, infinity)</span><br /><span class="line">            0   1   1   0   -Normal   (negative, valid, normalized)</span><br /><span class="line">            0   1   1   1   -Infinity (negative, infinity)</span><br /><span class="line">            1   0   0   0   +Zero     (positive, zero)</span><br /><span class="line">            1   0   0   1   Empty     (empty register)</span><br /><span class="line">            1   0   1   0   -Zero     (negative, zero)</span><br /><span class="line">            1   0   1   1   Empty     (empty register)</span><br /><span class="line">            1   1   0   0   +Denormal (positive, invalid, exponent is 0)</span><br /><span class="line">            1   1   0   1   Empty     (empty register)</span><br /><span class="line">            1   1   1   0   -Denormal (negative, invalid, exponent is 0)</span><br /><span class="line">            1   1   1   1   Empty     (empty register)</span><br /><span class="line"></span><br /><span class="line">FCOM or</span><br /><span class="line">STST        0   0   ?   0   ST &gt; Source with FCOM or ST &gt; 0 with FSTST</span><br /><span class="line">            0   0   ?   1   ST &lt; Source with FCOM or ST &lt; 0 with FSTST</span><br /><span class="line">            1   0   ?   0   ST = Source with FCOM or ST = 0 with FSTST</span><br /><span class="line">            1   1   ?   1   ST cannot be compared ot tested</span><br /><span class="line"></span><br /><span class="line">Reduction   b1  0   b0  b2  If reduction was complete, bits 0,1 and 2</span><br /><span class="line">                            equal the three lowest bits of the qoutient</span><br /><span class="line">            ?   1   ?   ?   Reduction was incomplete</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">FPU Status Word, Control Word and Tag Word layout</span><br /><span class="line">──────────────────────────────────────────────────────────────────────────────</span><br /><span class="line"></span><br /><span class="line">The layout of the Status-, Control- and Tag Word of the FPU.</span><br /><span class="line"></span><br /><span class="line">      FPU Status Word</span><br /><span class="line"></span><br /><span class="line">      Bit 15                8                        0</span><br /><span class="line">      ┌──┬──┬──┬──┼──┬──┬──┬──┼──┬──┬──┬──┼──┬──┬──┬─┴┐</span><br /><span class="line">      │ B│c3│  ST n  │c2│c1│c0│ES│sf│Pe│Ue│Oe│Ze│De│Ie│</span><br /><span class="line">      └─┼┴─┼┴─┼┴─┼┴─┼┴─┼┴─┼┴─┼┴─┼┴─┼┴─┼┴─┼┴─┼┴─┼┴─┼┴─┼┛</span><br /><span class="line">        │  │  └──┼──┛  └──┼──┛  │  │  │  │  │  │  │  │</span><br /><span class="line">      Busy ╘═════╪════════╡     │  │  │  │  │  │  │  │</span><br /><span class="line">      Stack Top──┛        │     │  │  │  │  │  │  │  │</span><br /><span class="line">      Condition Code Bits─┛     │  │  │  │  │  │  │  │</span><br /><span class="line">      Exception Summary * ──────┛  │  │  │  │  │  │  │</span><br /><span class="line">      Stack fault──────────────────┛  │  │  │  │  │  │</span><br /><span class="line">      Precision exception (1=occurred)┛  │  │  │  │  │</span><br /><span class="line">      Underflow exception (1=occurred)───┛  │  │  │  │</span><br /><span class="line">      Overflow exception (1=occurred)───────┛  │  │  │</span><br /><span class="line">      Zero divison exception (1=occurred)──────┛  │  │</span><br /><span class="line">      Denormalized operand exception (1=occurred)─┛  │</span><br /><span class="line">      Invalid operation exception (1=occurred)───────┛</span><br /><span class="line"></span><br /><span class="line">      * The Exception summary is called Interrupt request on 8087.</span><br /><span class="line"></span><br /><span class="line">      FPU Control Word</span><br /><span class="line"></span><br /><span class="line">      Bit 15                8                        0</span><br /><span class="line">      ┌──┬──┬──┬──┼──┬──┬──┬──┼──┬──┬──┬──┼──┬──┬──┬─┴┐</span><br /><span class="line">      │ r│ r│ r│ic│round│prec.│ie│ r│Pm│Um│Om│Zm│Dm│Im│</span><br /><span class="line">      └──┴──┴──┴─┼┴──┴─┼┴─┼┴──┴─┼┴──┴─┼┴─┼┴─┼┴─┼┴─┼┴─┼┛</span><br /><span class="line">      Infinity   │     │  │     │     │  │  │  │  │  │</span><br /><span class="line">      control────┛     │  │     │     │  │  │  │  │  │</span><br /><span class="line">      Rounding control─┛  │     │     │  │  │  │  │  │</span><br /><span class="line">      Precision control───┛     │     │  │  │  │  │  │</span><br /><span class="line">      Interrupt enable mask─────┛     │  │  │  │  │  │</span><br /><span class="line">                                      └┐ │  │  │  │  │</span><br /><span class="line">      Precision exception Mask 1=masked┛ │  │  │  │  │</span><br /><span class="line">      Underflow exception Mask 1=masked──┛  │  │  │  │</span><br /><span class="line">      Overflow exception Mask 1=masked──────┛  │  │  │</span><br /><span class="line">      Zero divison exception Mask 1=masked─────┛  │  │</span><br /><span class="line">      Denormalized operand exception Mask 1=masked┛  │</span><br /><span class="line">      Invalid operation exception Mask 1=masked──────┛</span><br /><span class="line"></span><br /><span class="line">    Infinity control is supported on the 8087 and 287 only.</span><br /><span class="line">    The 87 and 287 (not the 287xl) have ic cleared by default and then</span><br /><span class="line">    support projective closure. The 287xl+ only support affine closure.</span><br /><span class="line">    To make sure an 87 or 287 will handle the numbers in the same way</span><br /><span class="line">    as the 287xl+, set bit ic to make 87 &amp; 287 support affine closure</span><br /><span class="line">    as well. Note that a FINIT will clear ic again.</span><br /><span class="line">    The ic setting is ignored on 287xl+.</span><br /><span class="line"></span><br /><span class="line">    Rounding control is set to 00 by default.</span><br /><span class="line">    00 = Round to nearest or even</span><br /><span class="line">    01 = Round down (towards negative infinity)</span><br /><span class="line">    10 = Round up (towards positive infinity)</span><br /><span class="line">    11 = Chop towards zero</span><br /><span class="line"></span><br /><span class="line">    Precision control is set to 11 by default.</span><br /><span class="line">    00 = 24 bit precision (mantissa)</span><br /><span class="line">    01 = reserved</span><br /><span class="line">    10 = 53 bit precision (mantissa)</span><br /><span class="line">    11 = 64 bit precision (mantissa)</span><br /></pre>
  
  
  


      </article>

    </section>

  </body>

</html>

