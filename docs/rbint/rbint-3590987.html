





<!DOCTYPE html>
<html>

  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <meta name="generator" content="ng2web v1.1.0 (ngdb v1.1.0)">
    <link rel="stylesheet" type="text/css" href="rbint-style.css">
    <title>Ralf Brown » Lists » Interrupts</title>
    <meta name="description" content="Ralf Brown">
    <link rel="prev" href="rbint-3590502.html">
    <link rel="next" href="rbint-3602091.html">
    
  </head>

  <body>

    <header>
      <nav class="box">
        <ul>
          

<li><a href="rbint-about.html">About</a></li>


          

<li><a href="rbint-3590502.html">Previous</a></li>


          

<li><a href="rbint-3558542.html">Up</a></li>


          

<li><a href="rbint-3602091.html">Next</a></li>


        </ul>
      </nav>
    </header>

    <section>

      <nav class="menu box">
        <ul>
            <li>Lists</li>
            <ul>
              <li><a href="index.html">Comments</a></li>
              <li><a href="rbint-7995.html">Interrupts</a></li>
              <li><a href="rbint-15401.html">Glossary</a></li>
              <li><a href="rbint-64347.html">Memory</a></li>
              <li><a href="rbint-180090.html">CMOS</a></li>
              <li><a href="rbint-250757.html">86 Bugs</a></li>
              
            </ul>
        </ul>
      </nav>

      <article class="box">
        
  
  
    <pre class="entry"><span class="line"></span><br /><span class="line"><span class="ngu">Int 2F Fn 0802  U - Driver.sys Support - Execute Device Driver Request   </span>  [<span class="ngb">D</span>]</span><br /><span class="line"></span><br /><span class="line">   AX = 0802h</span><br /><span class="line">   ES:BX -&gt; device driver request header (see #2284)</span><br /><span class="line"></span><br /><span class="line"><span class="ngb">Return:</span> request header updated as per requested operation</span><br /><span class="line">   STACK:  WORD    original flags from INT call (left by RETF in device</span><br /><span class="line">             driver, at least in DOS 5.0-6.22)</span><br /><span class="line"></span><br /><span class="line"><span class="ngb">Notes:</span> supported by DR DOS 5.0</span><br /><span class="line">   DOS 3.2 executes this function on any AL value from 02h through F7h;</span><br /><span class="line">     DOS 4.0+ executes this function on AL=02h and AL=04h-F7h</span><br /><span class="line">   the command codes (see #2282) and structures described below apply</span><br /><span class="line">     to all drivers which support the appropriate commands; this call is</span><br /><span class="line">     just one of a number of ways in which a device driver request may</span><br /><span class="line">     be invoked</span><br /><span class="line">   supported by Novell DOS 7</span><br /><span class="line"></span><br /><span class="line"><span class="ngb">See Also:</span> AX=0800h,AX=0801h,AX=0803h,AX=1510h,INT 21/AH=52h,INT 21/AH=99h</span><br /><span class="line"></span><br /><span class="line"><span class="ngb">See Also:</span> INT 21/AH=9Ah</span><br /><span class="line"></span><br /><span class="line">(Table 2282)</span><br /><span class="line">Values for device driver command code:</span><br /><span class="line"> 00h (0)  INIT</span><br /><span class="line"> 01h (1)  MEDIA CHECK (block devices)</span><br /><span class="line"> 02h (2)  BUILD BPB (block devices)</span><br /><span class="line"> 03h (3)  IOCTL INPUT</span><br /><span class="line"> 04h (4)  INPUT</span><br /><span class="line"> 05h (5)  NONDESTRUCTIVE INPUT, NO WAIT (character devices)</span><br /><span class="line"> 06h (6)  INPUT STATUS (character devices)</span><br /><span class="line"> 07h (7)  INPUT FLUSH (character devices)</span><br /><span class="line"> 08h (8)  OUTPUT</span><br /><span class="line"> 09h (9)  OUTPUT WITH VERIFY</span><br /><span class="line"> 0Ah (10) OUTPUT STATUS (character devices)</span><br /><span class="line"> 0Bh (11) OUTPUT FLUSH (character devices)</span><br /><span class="line"> 0Ch (12) IOCTL OUTPUT</span><br /><span class="line"> 0Dh (13) (DOS 3.0+) DEVICE OPEN</span><br /><span class="line"> 0Eh (14) (DOS 3.0+) DEVICE CLOSE</span><br /><span class="line"> 0Fh (15) (DOS 3.0+) REMOVABLE MEDIA (block devices)</span><br /><span class="line"> 10h (16) (DOS 3.0+) OUTPUT UNTIL BUSY (character devices)</span><br /><span class="line"> 11h (17) (European MS-DOS 4.0) STOP OUTPUT (console screen drivers only)</span><br /><span class="line"> 12h (18) (European MS-DOS 4.0) RESTART OUTPUT (console screen drivers only)</span><br /><span class="line"> 13h (19) (DOS 3.2+) GENERIC IOCTL</span><br /><span class="line"> 14h (20) unused</span><br /><span class="line"> 15h (21) (European MS-DOS 4.0) RESET UNCERTAIN MEDIA FLAG</span><br /><span class="line"> 16h (22) unused</span><br /><span class="line"> 17h (23) (DOS 3.2+) GET LOGICAL DEVICE</span><br /><span class="line"> 18h (24) (DOS 3.2+) SET LOGICAL DEVICE</span><br /><span class="line"> 19h (25) (DOS 5.0+) CHECK GENERIC IOCTL SUPPORT</span><br /><span class="line"> 80h (128)(CD-ROM) READ LONG</span><br /><span class="line"> 81h (129)(CD-ROM) reserved</span><br /><span class="line"> 82h (130)(CD-ROM) READ LONG PREFETCH</span><br /><span class="line"> 83h (131)(CD-ROM) SEEK</span><br /><span class="line"> 84h (132)(CD-ROM) PLAY AUDIO</span><br /><span class="line"> 85h (133)(CD-ROM) STOP AUDIO</span><br /><span class="line"> 86h (134)(CD-ROM) WRITE LONG</span><br /><span class="line"> 87h (135)(CD-ROM) WRITE LONG VERIFY</span><br /><span class="line"> 88h (136)(CD-ROM) RESUME AUDIO</span><br /><span class="line"></span><br /><span class="line">Bitfields for device request status:</span><br /><span class="line">Bit(s) Description (Table 2283)</span><br /><span class="line"> 15    error</span><br /><span class="line"> 14-11 reserved</span><br /><span class="line"> 10    ??? set by DOS kernel on entry to some driver calls</span><br /><span class="line"> 9 busy</span><br /><span class="line"> 8 done (may be clear on return under European MS-DOS 4.0)</span><br /><span class="line"> 7-0   error code if bit 15 set (see #2285)</span><br /><span class="line"></span><br /><span class="line">Format of device driver request header:</span><br /><span class="line">Offset Size    Description (Table 2284)</span><br /><span class="line"> 00h   BYTE    length of request header</span><br /><span class="line"> 01h   BYTE    subunit within device driver</span><br /><span class="line"> 02h   BYTE    command code (see #2282)</span><br /><span class="line"> 03h   WORD    status (filled in by device driver) (see #2283)</span><br /><span class="line">---DOS---</span><br /><span class="line"> 05h  4 BYTEs  reserved (unused in DOS 2.x and 3.x)</span><br /><span class="line"> 09h   DWORD   (European MS-DOS 4.0 only) pointer to next request header in</span><br /><span class="line">             device&#39;s request queue</span><br /><span class="line">       (other versions) reserved (unused in DOS 2.x and 3.x)</span><br /><span class="line">---STARLITE architecture---</span><br /><span class="line"> 05h   DWORD   pointer to next request header</span><br /><span class="line"> 09h  4 BYTEs  reserved</span><br /><span class="line">---command code 00h---</span><br /><span class="line"> 0Dh   BYTE    (ret) number of units</span><br /><span class="line"> 0Eh   DWORD   (call) pointer to DOS device helper function (see #2286)</span><br /><span class="line">             (European MS-DOS 4.0 only)</span><br /><span class="line">       (call) pointer past end of memory available to driver (DOS 5+)</span><br /><span class="line">       (ret) address of first free byte following driver</span><br /><span class="line"> 12h   DWORD   (call) pointer to commandline arguments</span><br /><span class="line">       (ret) pointer to BPB array (block drivers) or</span><br /><span class="line">             0000h:0000h (character drivers)</span><br /><span class="line"> 16h   BYTE    (DOS 3.0+) drive number for first unit of block driver (0=A)</span><br /><span class="line">   ---European MS-DOS 4.0---</span><br /><span class="line"> 17h   DWORD   pointer to function to save registers on stack</span><br /><span class="line">   ---DOS 5+ ---</span><br /><span class="line"> 17h   WORD    (ret) error-message flag</span><br /><span class="line">       0001h MS-DOS should display error msg on init failure</span><br /><span class="line">---command code 01h---</span><br /><span class="line"> 0Dh   BYTE    media descriptor</span><br /><span class="line"> 0Eh   BYTE    (ret) media status</span><br /><span class="line">       00h don&#39;t know</span><br /><span class="line">       01h media has not changed</span><br /><span class="line">       FFh media has been changed</span><br /><span class="line"> 0Fh   DWORD   (ret, DOS 3.0+) pointer to previous volume ID if the</span><br /><span class="line">         OPEN/CLOSE/RM bit in device header is set and disk changed</span><br /><span class="line">---command code 02h---</span><br /><span class="line"> 0Dh   BYTE    media descriptor</span><br /><span class="line"> 0Eh   DWORD   transfer address</span><br /><span class="line">       -&gt; scratch sector if NON-IBM FORMAT bit in device header set</span><br /><span class="line">       -&gt; first FAT sector otherwise</span><br /><span class="line"> 12h   DWORD   pointer to BPB (set by driver) (see #1349 at INT 21/AH=53h)</span><br /><span class="line">---command codes 03h,0Ch---</span><br /><span class="line">         (see also INT 21/AX=4402h&#34;DOS 2+&#34;,INT 21/AX=4403h&#34;DOS&#34;)</span><br /><span class="line"> 0Dh   BYTE    media descriptor (block devices only)</span><br /><span class="line"> 0Eh   DWORD   transfer address</span><br /><span class="line"> 12h   WORD    (call) number of bytes to read/write</span><br /><span class="line">       (ret) actual number of bytes read or written</span><br /><span class="line">---command codes 04h,08h,09h (except Compaq DOS 3.31, DR DOS 6)---</span><br /><span class="line"> 0Dh   BYTE    media descriptor (block devices only)</span><br /><span class="line"> 0Eh   DWORD   transfer address</span><br /><span class="line"> 12h   WORD    byte count (character devices) or sector count (block devices)</span><br /><span class="line"> 14h   WORD    starting sector number (block devices only)</span><br /><span class="line"> 16h   DWORD   (DOS 3.0+) pointer to volume ID if error 0Fh returned</span><br /><span class="line"> 1Ah   DWORD   (DOS 4.0+) 32-bit starting sector number (block devices with</span><br /><span class="line">         device attribute word bit 1 set only) if starting sector</span><br /><span class="line">         number above is FFFFh (see INT 21/AH=52h)</span><br /><span class="line">---command codes 04h,08h,09h (Compaq DOS 3.31, DR DOS 6)---</span><br /><span class="line"> 0Dh   BYTE    media descriptor (block devices only)</span><br /><span class="line"> 0Eh   DWORD   transfer address</span><br /><span class="line"> 12h   WORD    byte count (character devices) or sector count (block devices)</span><br /><span class="line"> 14h   DWORD   32-bit starting sector number (block devices only)</span><br /><span class="line"></span><br /><span class="line">   <span class="ngb">Note:</span>   to reliably determine which variant of the request block for</span><br /><span class="line">         functions 04h,08h,09h has been passed to the driver, check</span><br /><span class="line">         the length field as well as the word at offset 14h.  If the</span><br /><span class="line">         length is 1Eh and 14h=FFFFh, use the DWORD at 1Ah as the</span><br /><span class="line">         starting sector number; if the length is 18h, use the DWORD</span><br /><span class="line">         at 14h; otherwise, use the WORD at 14h.</span><br /><span class="line">---command code 05h---</span><br /><span class="line"> 0Dh   BYTE    byte read from device if BUSY bit clear on return</span><br /><span class="line">---command codes 06h,07h,0Ah,0Bh,0Dh,0Eh,0Fh---</span><br /><span class="line"> no further fields</span><br /><span class="line">---command code 10h---</span><br /><span class="line"> 0Dh   BYTE    unused</span><br /><span class="line"> 0Eh   DWORD   transfer address</span><br /><span class="line"> 12h   WORD    (call) number of bytes to write</span><br /><span class="line">       (ret) actual number of bytes written</span><br /><span class="line">---command codes 11h,12h---</span><br /><span class="line"> 0Dh   BYTE    reserved</span><br /><span class="line">---command code 15h---</span><br /><span class="line"> no further fields</span><br /><span class="line">---command codes 13h,19h---</span><br /><span class="line"> 0Dh   BYTE    category code</span><br /><span class="line">       00h unknown</span><br /><span class="line">       01h COMn:</span><br /><span class="line">       03h CON</span><br /><span class="line">       05h LPTn:</span><br /><span class="line">       07h mouse (European MS-DOS 4.0)</span><br /><span class="line">       08h disk</span><br /><span class="line">       9Eh (STARLITE) Media Access Control driver</span><br /><span class="line"> 0Eh   BYTE    function code</span><br /><span class="line">       00h (STARLITE) MAC Bind request</span><br /><span class="line"> 0Fh   WORD    copy of DS at time of IOCTL call (apparently unused in DOS 3.3)</span><br /><span class="line">       SI contents (European MS-DOS 4.0)</span><br /><span class="line"> 11h   WORD    offset of device driver header (see #1332)</span><br /><span class="line">       DI contents (European MS-DOS 4.0)</span><br /><span class="line"> 13h   DWORD   pointer to parameter block from INT 21/AX=440Ch or AX=440Dh</span><br /><span class="line">---command codes 80h,82h---</span><br /><span class="line"> 0Dh   BYTE    addressing mode</span><br /><span class="line">       00h HSG (default)</span><br /><span class="line">       01h Phillips/Sony Red Book</span><br /><span class="line"> 0Eh   DWORD   transfer address (ignored for command 82h)</span><br /><span class="line"> 12h   WORD    number of sectors to read</span><br /><span class="line">       (if 0 for command 82h, request is an advisory seek)</span><br /><span class="line"> 14h   DWORD   starting sector number</span><br /><span class="line">       logical sector number in HSG mode</span><br /><span class="line">       frame/second/minute/unused in Red Book mode</span><br /><span class="line">       (HSG sector = minute * 4500 + second * 75 + frame - 150)</span><br /><span class="line"> 18h   BYTE    data read mode</span><br /><span class="line">       00h cooked (2048 bytes per frame)</span><br /><span class="line">       01h raw (2352 bytes per frame, including EDC/ECC)</span><br /><span class="line"> 19h   BYTE    interleave size (number of sectors stored consecutively)</span><br /><span class="line"> 1Ah   BYTE    interleave skip factor</span><br /><span class="line">       (number of sectors between consecutive portions)</span><br /><span class="line">---command code 83h---</span><br /><span class="line"> 0Dh   BYTE    addressing mode</span><br /><span class="line">       00h HSG (default)</span><br /><span class="line">       01h Phillips/Sony Red Book</span><br /><span class="line"> 0Eh   DWORD   transfer address (ignored)</span><br /><span class="line"> 12h   WORD    number of sectors to read (ignored)</span><br /><span class="line"> 14h   DWORD   starting sector number (see also above)</span><br /><span class="line">---command code 84h---</span><br /><span class="line"> 0Dh   BYTE    addressing mode</span><br /><span class="line">       00h HSG (default)</span><br /><span class="line">       01h Phillips/Sony Red Book</span><br /><span class="line"> 0Eh   DWORD   starting sector number (see also above)</span><br /><span class="line"> 12h   DWORD   number of sectors to play</span><br /><span class="line">---command codes 85h,88h---</span><br /><span class="line"> no further fields</span><br /><span class="line">---command codes 86h,87h---</span><br /><span class="line"> 0Dh   BYTE    addressing mode</span><br /><span class="line">       00h HSG (default)</span><br /><span class="line">       01h Phillips/Sony Red Book</span><br /><span class="line"> 0Eh   DWORD   transfer address (ignored in write mode 0)</span><br /><span class="line"> 12h   WORD    number of sectors to write</span><br /><span class="line"> 14h   DWORD   starting sector number (also see above)</span><br /><span class="line"> 18h   BYTE    write mode</span><br /><span class="line">       00h mode 0 (write all zeros)</span><br /><span class="line">       01h mode 1 (default) (2048 bytes per sector)</span><br /><span class="line">       02h mode 2 form 1 (2048 bytes per sector)</span><br /><span class="line">       03h mode 2 form 2 (2336 bytes per sector)</span><br /><span class="line"> 19h   BYTE    interleave size (number of sectors stored consecutively)</span><br /><span class="line"> 1Ah   BYTE    interleave skip factor</span><br /><span class="line">       (number of sectors between consecutive portions)</span><br /><span class="line"></span><br /><span class="line">(Table 2285)</span><br /><span class="line">Values for device driver error code:</span><br /><span class="line"> 00h   write-protect violation</span><br /><span class="line"> 01h   unknown unit</span><br /><span class="line"> 02h   drive not ready</span><br /><span class="line"> 03h   unknown command</span><br /><span class="line"> 04h   CRC error</span><br /><span class="line"> 05h   bad drive request structure length</span><br /><span class="line"> 06h   seek error</span><br /><span class="line"> 07h   unknown media</span><br /><span class="line"> 08h   sector not found</span><br /><span class="line"> 09h   printer out of paper</span><br /><span class="line"> 0Ah   write fault</span><br /><span class="line"> 0Bh   read fault</span><br /><span class="line"> 0Ch   general failure</span><br /><span class="line"> 0Dh   reserved</span><br /><span class="line"> 0Eh   (CD-ROM) media unavailable</span><br /><span class="line"> 0Fh   invalid disk change</span><br /><span class="line"></span><br /><span class="line">(Table 2286)</span><br /><span class="line">Call European MS-DOS 4.0 device helper function with:</span><br /><span class="line">   DL = function</span><br /><span class="line">       00h &#34;SchedClock&#34; called on each timer tick</span><br /><span class="line">       AL = tick interval in milliseconds</span><br /><span class="line">       01h &#34;DevDone&#34; device I/O complete</span><br /><span class="line">       ES:BX -&gt; request header</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Note:</span>   must update status word first; may be called from</span><br /><span class="line">             an interrupt handler</span><br /><span class="line">       02h &#34;PullRequest&#34; pull next request from queue</span><br /><span class="line">       DS:SI -&gt; DWORD pointer to start of device&#39;s request queue</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> ZF clear if pending request</span><br /><span class="line">               ES:BX -&gt; request header</span><br /><span class="line">           ZF set if no more requests</span><br /><span class="line">       03h &#34;PullParticular&#34; remove specific request from queue</span><br /><span class="line">       DS:SI -&gt; DWORD pointer to start of device&#39;s request queue</span><br /><span class="line">       ES:BX -&gt; request header</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> ZF set if request header not found</span><br /><span class="line">       04h &#34;PushRequest&#34; push the request onto the queue</span><br /><span class="line">       DS:SI -&gt; DWORD pointer to start of device&#39;s request queue</span><br /><span class="line">       ES:BX -&gt; request header</span><br /><span class="line">       interrupts disabled</span><br /><span class="line">       05h &#34;ConsInputFilter&#34; keyboard input check</span><br /><span class="line">       AX = character (high byte 00h if PC ASCII character)</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> ZF set if character should be discarded</span><br /><span class="line">           ZF clear if character should be handled normally</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Note:</span>   called by keyboard interrupt handler so DOS can scan</span><br /><span class="line">             for special input characters</span><br /><span class="line">       06h &#34;SortRequest&#34; push request in sorted order by starting sector</span><br /><span class="line">       DS:SI -&gt; DWORD pointer to start of device&#39;s request queue</span><br /><span class="line">       ES:BX -&gt; request header</span><br /><span class="line">       interrupts disabled</span><br /><span class="line">       07h &#34;SigEvent&#34; send signal on keyboard event</span><br /><span class="line">       AH = event identifier</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> AL,FLAGS destroyed</span><br /><span class="line">       09h &#34;ProcBlock&#34; block on event</span><br /><span class="line">       AX:BX = event identifier (typically a pointer)</span><br /><span class="line">       CX = timeout in ms or 0000h for never</span><br /><span class="line">       DH = interruptable flag (nonzero if pause may be interrupted)</span><br /><span class="line">       interrupts disabled</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> after corresponding ProcRun call</span><br /><span class="line">           CF clear if event wakeup, set if unusual wakeup</span><br /><span class="line">           ZF set if timeout wakeup, clear if interrupted</span><br /><span class="line">           AL = wakeup code, nonzero if unusual wakeup</span><br /><span class="line">           interrupts enabled</span><br /><span class="line">           BX,CX,DX destroyed</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Note:</span>   block process and schedules another to run</span><br /><span class="line">       0Ah &#34;ProcRun&#34; unblock process</span><br /><span class="line">       AX:BX = event identifier (typically a pointer)</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> AX = number of processes awakened</span><br /><span class="line">           ZF set if no processes awakened</span><br /><span class="line">           BX,CX,DX destroyed</span><br /><span class="line">       0Bh &#34;QueueInit&#34; initialize/clear character queue</span><br /><span class="line">       DS:BX -&gt; character queue structure (see #2287)</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line"><span class="ngb">.NG limit reached, continued in next section...</span></span><br /></pre>
  
  
  


      </article>

    </section>

  </body>

</html>

