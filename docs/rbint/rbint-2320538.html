





<!DOCTYPE html>
<html>

  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <meta name="generator" content="ng2web v1.2.0 (ngdb v1.1.0)">
    <link rel="stylesheet" type="text/css" href="rbint-style.css">
    <title>Ralf Brown » Lists » Interrupts</title>
    <meta name="description" content="Ralf Brown">
    <link rel="prev" href="rbint-2309281.html">
    <link rel="next" href="rbint-2329857.html">
    
  </head>

  <body>

    <header>
      <nav class="box">
        <ul>
          

<li><a href="../index.html">Guides</a></li>


          

<li><a href="rbint-about.html">About</a></li>


          

<li><a href="rbint-2309281.html">Previous</a></li>


          

<li><a href="rbint-2204700.html">Up</a></li>


          

<li><a href="rbint-2329857.html">Next</a></li>


        </ul>
      </nav>
    </header>

    <section>

      
        <nav class="menu box">
          <ul>
              <li>Lists</li>
              <ul>
                <li><a href="index.html">Comments</a></li>
                <li><a href="rbint-7995.html">Interrupts</a></li>
                <li><a href="rbint-15401.html">Glossary</a></li>
                <li><a href="rbint-64347.html">Memory</a></li>
                <li><a href="rbint-180090.html">CMOS</a></li>
                <li><a href="rbint-250757.html">86 Bugs</a></li>
                
              </ul>
          </ul>
        </nav>
      

      <article class="box">
        
  
  
    <pre class="entry"><span class="line"></span><br /><span class="line"><span class="ngu">Int 21 Fn 4402  U - Qualitas 386max V6.00+ - Ioctl Input - Get State  <span class="ngb">(Cont.)</span></span></span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> AH = 00h (successful)</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Note:</span>   enables A20 first</span><br /><span class="line">   AH = 0Dh specify 386MAX high-memory location</span><br /><span class="line">       BX = segment address of high-memory real-mode portion of 386MAX</span><br /><span class="line">       CX = current segment of real-mode stub???</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> AH = status (00h successful)</span><br /><span class="line">           ???</span><br /><span class="line">   AH = 0Eh CRT controller register virtualization</span><br /><span class="line">       AL = subfunction</span><br /><span class="line">           00h allow access to CRTC I/O ports 03B4h/03B5h, 03D4h/03D5h</span><br /><span class="line">           01h trap accesses to CRTC I/O ports</span><br /><span class="line">   AH = 0Fh reboot system</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> never</span><br /><span class="line">   AH = 10h unused</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> AH = 84h (unsupported function)</span><br /><span class="line">   AH = 11h get high memory information</span><br /><span class="line">       ES:DI -&gt; 96-byte buffer for high memory info</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> AH = 00h (successful)</span><br /><span class="line">           ES:DI buffer filled</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Notes:</span>  each byte in buffer contains bit flags for a 4K page in</span><br /><span class="line">             the A000h-FFFFh region</span><br /><span class="line">               bit 0: page is writeable</span><br /><span class="line">               bit 1: physical address same as linear address</span><br /><span class="line">               bit 2: EMS page frame</span><br /><span class="line">               bit 6: page is part of the QPMS window</span><br /><span class="line">           this function can take over a second to execute,</span><br /><span class="line">             because it does a 128K read for each page in an</span><br /><span class="line">             attempt to flush any RAM cache the system may have</span><br /><span class="line">   AH = 12h shadow RAM mapping</span><br /><span class="line">       AL = subfunction</span><br /><span class="line">           00h unshadow ROMs (except page FFh if NOWARMBOOT set)</span><br /><span class="line">           01h map shadow RAM into ROM regions???</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> AH = 00h (successful) if AL=00h or 01h</span><br /><span class="line">           AH = 8Fh otherwise</span><br /><span class="line">   AH = 13h shadow RAM page protection</span><br /><span class="line">       AL = subfunction</span><br /><span class="line">           00h set all shadowed ROM 4K pages to read-only</span><br /><span class="line">           01h set all shadowed ROM 4K pages to read-write</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> AH = 00h (successful) if AL=00h or 01h</span><br /><span class="line">           AH = 8Fh otherwise</span><br /><span class="line">   AH = 14h get Programmable Option Select info???</span><br /><span class="line">       ES:DI -&gt; 54-byte buffer for POS data???</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> AH = 00h if successful</span><br /><span class="line">           AH = A4h on error</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Note:</span>   the buffer consists of nine 6-byte fields; the first</span><br /><span class="line">             eight for slots 1-8, the last for the system board</span><br /><span class="line">   AH = 15h ???</span><br /><span class="line">       ???</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> ???</span><br /><span class="line">   AH = 16h get 386MAX memory usage screen</span><br /><span class="line">       ES:DI -&gt; buffer for memory info display</span><br /><span class="line">       CX = size of buffer in bytes</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> ES:DI buffer filled with &#39;$&#39;-terminated string (if</span><br /><span class="line">               large enough to hold entire usage screen)</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Note:</span>   the screen is 0303h bytes in v7.00</span><br /><span class="line">   AH = 17h Windows 3 startup/termination</span><br /><span class="line">       AL = subfunction</span><br /><span class="line">           00h Windows3 initializing</span><br /><span class="line">           DX (on stack) = Windows startup flags</span><br /><span class="line">           DI = Windows version number (major in upper byte)</span><br /><span class="line">           ES:BX = 0000h:0000h</span><br /><span class="line">           DS:SI = 0000h:0000h</span><br /><span class="line"></span><br /><span class="line">           <span class="ngb">Return:</span> CX = 0000h if OK for Windows to load</span><br /><span class="line">                  &lt;&gt; 0 if Windows should not load</span><br /><span class="line">               ES:BX -&gt; startup info structure</span><br /><span class="line">               DS:SI -&gt; Virtual86 mode enable/disable callback</span><br /><span class="line">           01h Windows3 terminating</span><br /><span class="line">           ES:BX -&gt; ???</span><br /><span class="line">           DX (on stack) = Windows exit flags</span><br /><span class="line"></span><br /><span class="line">           <span class="ngb">Return:</span> ???</span><br /><span class="line">   AH = 18h QPMS (Qualitas Protected Memory Services)</span><br /><span class="line">       AL = subfunction</span><br /><span class="line">           00h get QPMS configuration</span><br /><span class="line"></span><br /><span class="line">           <span class="ngb">Return:</span> BX = starting segment of QPMS memory window</span><br /><span class="line">               CX = number of 4K pages reserved for QPMS???</span><br /><span class="line">               DX = number of 4K pages in QPMS window???</span><br /><span class="line">           01h map QPMS memory page???</span><br /><span class="line">           BX = 4K page number within memory reserved for QPMS???</span><br /><span class="line">           CL = 4K page number within QPMS memory window???</span><br /><span class="line">           02h mark all QPMS memory read-only</span><br /><span class="line">           03h mark all QPMS memory read-write</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> AH = status (00h,8Ah,8Bh,8Fh)</span><br /><span class="line">   AH = 19h get linear address for physical address</span><br /><span class="line">       EDX = physical address (low word on stack)</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> AH = status</span><br /><span class="line">               00h successful</span><br /><span class="line">               EDX = linear address at which physical address</span><br /><span class="line">                   may be accessed</span><br /><span class="line">               8Bh physical address currently not addressable</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Note:</span>   enables A20 first</span><br /><span class="line">   AH = 1Ah set page table entry</span><br /><span class="line">       EDX = new page table entry (low word on stack)</span><br /><span class="line">       ESI = linear address of page to map (bits 0-11 clear)</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> AH = status (00h,8Bh)</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Note:</span>   enables A20 first</span><br /><span class="line">   AH = 1Bh get ???</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> AH = status</span><br /><span class="line">           BX = ???</span><br /><span class="line">           CX = number of ???</span><br /><span class="line">           EDX = physical address of ???</span><br /><span class="line">   AH = 1Ch get original interrupt vector</span><br /><span class="line">       AL = interrupt vector (00h-7Fh)</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> AH = 00h (successful)</span><br /><span class="line">           EDX = original vector before 386MAX loaded (segment in</span><br /><span class="line">               high word, offset in low word)</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Note:</span>   no range checking is performed; requests for INTs 80h-</span><br /><span class="line">             FFh will return random values</span><br /><span class="line">   AH = 1Dh display string???</span><br /><span class="line">       SI = ???</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> AH = 00h (successful)</span><br /><span class="line">           ???</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Note:</span>   this function appears to be broken in v7.00</span><br /><span class="line">   AH = 1Eh get memory info</span><br /><span class="line">       ES:DI -&gt; memory info (see #1170)</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> ???</span><br /><span class="line">   AH = 1Fh get DPMI host information</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> AX = 0000h if successful</span><br /><span class="line">           BX = DPMI flags (see #2823 at INT 31/AX=0400h)</span><br /><span class="line">           CL = CPU type (02h = 80286, 03h = 80386, etc.)</span><br /><span class="line">           DX = DPMI ver supported (DH=major, DL=2-digit minor)</span><br /><span class="line">           SI = ???</span><br /><span class="line">           ES???:DI -&gt; ???</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Note:</span>   NOP if NODPMI switch specified</span><br /><span class="line">   AH = 20h (v7.00) get ???</span><br /><span class="line">       AL = index of ???</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> EDX = ??? for specified ???</span><br /><span class="line">   AH = 21h (v7.00) STACKS support</span><br /><span class="line">       AL = 00h get STACKS parameters</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> BX = ??? (0060h for v7.00)</span><br /><span class="line">           CX = number of stacks for hardware interrupts</span><br /><span class="line">           DX = size of each stack in bytes</span><br /><span class="line">           SI = ??? (low and high bytes are separate values)</span><br /><span class="line">           DI = ??? (low and high bytes are separate values)</span><br /><span class="line">               low byte = logical page number set by subfn 02h</span><br /><span class="line">           ES = ???</span><br /><span class="line">       AL = 01h set ??? &#34;EMM2_DSTKS&#34;</span><br /><span class="line">       EBX = ???</span><br /><span class="line">       ECX = ???</span><br /><span class="line">       AL = 02h set ???</span><br /><span class="line">       BL = logical page number for ??? (00h-03h)</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> AH = status (00h,8Ah)</span><br /><span class="line">   AH = 22h (v7.00) call ??? for every load module</span><br /><span class="line">       AL = which function to call</span><br /><span class="line">       00h call ???</span><br /><span class="line">       else call ????</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> AH = 00h</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Note:</span> if AL=00h, calls the protected-mode function pointed at by</span><br /><span class="line">       the DWORD at offset 22h from the start of each module installed</span><br /><span class="line">       by a LOAD= directive; if AL&lt;&gt;00h, it calls the function</span><br /><span class="line">       pointed at by the DWORD at offset 28h of the load module</span><br /><span class="line">   AH = 23h (v7.00) ???</span><br /><span class="line">       AL = 00h set ???</span><br /><span class="line">       BL = ???</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> AH = 00h or unchanged (depending on ???)</span><br /><span class="line">       AL = 01h set ???</span><br /><span class="line">       BL = ???</span><br /><span class="line">       BH = ???</span><br /><span class="line">       CX = ???</span><br /><span class="line">       DX = ??? (on top of stack)</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> AH = status (00h if successful, 8Fh once table full)</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Note:</span>   this call adds one entry to an internal table on each</span><br /><span class="line">             call, until the table is full</span><br /><span class="line">       AL = 02h get ???</span><br /><span class="line">       CX = size of buffer</span><br /><span class="line">       ES:DI -&gt; buffer for ??? (60 bytes total data)</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> CX = number of bytes actually returned</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Note:</span>   returns the array storing the values set with AX=2301h</span><br /><span class="line">       Format of one entry in array:</span><br /><span class="line">       Offset  Size    Description</span><br /><span class="line">        00h    BYTE    ??? (BL from subfn 01h)</span><br /><span class="line">        01h    WORD    ??? (CX from subfn 01h)</span><br /><span class="line">        03h    BYTE    ??? (BH from subfn 01h)</span><br /><span class="line">        04h    WORD    ??? (DX from subfn 01h)</span><br /><span class="line">       AL = 03h set ??? name/path</span><br /><span class="line">       ES:DI -&gt; buffer containing ASCIZ ???</span><br /><span class="line">       AL = 04h get ???</span><br /><span class="line">       ES:DI -&gt; buffer for ASCIZ ???</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Note:</span> the ASCIZ string for subfunctions 03h and 04h does not appear</span><br /><span class="line">       to be used by 386MAX, and may serve merely for communication</span><br /><span class="line">       between two other Qualitas programs</span><br /><span class="line">   AH = 24h (v7.00) high memory control</span><br /><span class="line">       AL = 00h get high memory state</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> BX = current state</span><br /><span class="line">               00h high memory removed from DOS memory chain</span><br /><span class="line">               01h high memory included in DOS memory chain</span><br /><span class="line">       AL = 01h set high memory state</span><br /><span class="line">       BX = new state</span><br /><span class="line">           00h high memory removed from DOS memory chain</span><br /><span class="line">           01h high memory included in DOS memory chain</span><br /><span class="line">           else</span><br /><span class="line"></span><br /><span class="line">           <span class="ngb">Return:</span> ??? (error, but return varies according to ???)</span><br /><span class="line">   AH = 25h (v7.00) remove high RAM from DOS memory chain</span><br /><span class="line">   AH = 26h (v7.00) ???</span><br /><span class="line">       BX = ???</span><br /><span class="line">       CX = ???</span><br /><span class="line">       SI = ???</span><br /><span class="line">       DI = ???</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> AH = status</span><br /><span class="line">           BX = ???</span><br /><span class="line">           CX = ???</span><br /><span class="line">   AH = 27h (v7.00) ???</span><br /><span class="line">       AL = 00h get ???</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> BX = number of paragraphs for ???</span><br /><span class="line">       AL = 01h ???</span><br /><span class="line">       BX = ???</span><br /><span class="line">       ES??? = ???</span><br /><span class="line">       AL = 02h ???</span><br /><span class="line">       ???</span><br /><span class="line">       AL = 03h ???</span><br /><span class="line">       CX = ???</span><br /><span class="line">       DX = ???</span><br /><span class="line">       ES??? = ???</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> ???</span><br /><span class="line">   AH = 28h (v7.00) get ???</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> AH = status (00h,8Fh) (see #3319 at INT 67/AH=40h)</span><br /><span class="line">           if AH=00h,</span><br /><span class="line">               CX = ???</span><br /><span class="line">               DX = ???</span><br /><span class="line">   AH = 29h (v7.00) get ???</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> AX = ???</span><br /><span class="line">   AH = 40h-5Dh EMS services (see INT 67/AH=40h, etc.)</span><br /><span class="line">   AH = DEh VCPI services (see INT 67/AX=DE00h, etc.)</span><br /><span class="line"></span><br /><span class="line"><span class="ngb">Return:</span> AH = status (as for EMS INT 67 calls)</span><br /><span class="line">       00h successful</span><br /><span class="line">       80h internal error</span><br /><span class="line">       81h hardware malfunction</span><br /><span class="line">       83h invalid handle</span><br /><span class="line">       84h undefined function</span><br /><span class="line">       8Ah invalid logical page nuber</span><br /><span class="line">       8Bh illegal physical page number</span><br /><span class="line">       8Fh undefined subfunction</span><br /><span class="line">       A4h access denied</span><br /><span class="line">       etc.</span><br /><span class="line">   STACK popped (value placed in DX if no specific return value for DX)</span><br /><span class="line"></span><br /><span class="line">Format of 386MAX memory speed record:</span><br /><span class="line">Offset Size    Description (Table 1169)</span><br /><span class="line"> 00h   DWORD   page table entry for 4K page</span><br /><span class="line"> 04h   WORD    number of microticks (840ns units) required for REP LODSD of</span><br /><span class="line">         entire 4K page</span><br /><span class="line"></span><br /><span class="line">Format of 386MAX memory info [array]:</span><br /><span class="line">Offset Size    Description (Table 1170)</span><br /><span class="line"> 00h   DWORD   linear start address</span><br /><span class="line"> 04h   DWORD   size in bytes</span><br /><span class="line"> 08h   WORD    XMS handle (if next byte = 04h)</span><br /><span class="line">       ??? (if next byte = 05h)</span><br /><span class="line">       ??? (if next byte = 06h)</span><br /><span class="line">       ??? (if next byte = 13h)</span><br /><span class="line">       ??? (if next byte = 14h)</span><br /><span class="line">       ??? (if next byte = 15h)</span><br /><span class="line">       ??? (if next byte = 23h)</span><br /><span class="line">       ??? (if next byte = 24h)</span><br /><span class="line">       ??? (if next byte = 26h)</span><br /><span class="line">       else unused</span><br /><span class="line"> 0Ah   BYTE    type</span><br /><span class="line">       00h = ???, 01h = VDISK,</span><br /><span class="line">       02h = INT 15h extended memory, 03h = ??? extended,</span><br /><span class="line">       04h = XMS handle&#39;s memory, 05h = ???, 06h = ???, 07h = ???,</span><br /><span class="line">       08h = ???, 09h = ???, 0Ah = ???, 0Bh = ???,</span><br /><span class="line">       11h = ???, 12h = ???, 14h = ???, 15h = ???,</span><br /><span class="line">       19h = ???, 1Ah = ???, 1Bh = ???,</span><br /><span class="line">       1Ch = ???, 1Dh = ???, 1Eh = ???, 1Fh = ???,</span><br /><span class="line">       20h = ???, 21h = ???, 23h = ???, 24h = ???,</span><br /><span class="line">       26h = ???</span><br /><span class="line"> 0Bh   BYTE    ??? (00h for types 00h-03h, 07h-0Bh, 19h-21h;</span><br /><span class="line">            80h for types 04h/13h-15h/23h-26h;</span><br /><span class="line">           ??? for type 05h)</span><br /></pre>
  
  
  


      </article>

    </section>

    
      <footer>
        <nav class="box">
          <dl>
            <dt>Generated</dt><dd>2025-12-02 09:10:33</dd>
            <dt>Generator</dt><dd><a href="https://ng2web.davep.dev">ng2web v1.2.0 (ngdb v1.1.0)</a></dd>
          </dl>
        </nav>
      </footer>
    

  </body>

</html>

