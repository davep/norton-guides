





<!DOCTYPE html>
<html>

  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <meta name="generator" content="ng2web v1.1.0 (ngdb v1.1.0)">
    <link rel="stylesheet" type="text/css" href="rbint-style.css">
    <title>Ralf Brown » Lists » Interrupts</title>
    <meta name="description" content="Ralf Brown">
    <link rel="prev" href="rbint-2301192.html">
    <link rel="next" href="rbint-2320538.html">
    
  </head>

  <body>

    <header>
      <nav class="box">
        <ul>
          

<li><a href="../index.html">Guides</a></li>


          

<li><a href="rbint-about.html">About</a></li>


          

<li><a href="rbint-2301192.html">Previous</a></li>


          

<li><a href="rbint-2204700.html">Up</a></li>


          

<li><a href="rbint-2320538.html">Next</a></li>


        </ul>
      </nav>
    </header>

    <section>

      <nav class="menu box">
        <ul>
            <li>Lists</li>
            <ul>
              <li><a href="index.html">Comments</a></li>
              <li><a href="rbint-7995.html">Interrupts</a></li>
              <li><a href="rbint-15401.html">Glossary</a></li>
              <li><a href="rbint-64347.html">Memory</a></li>
              <li><a href="rbint-180090.html">CMOS</a></li>
              <li><a href="rbint-250757.html">86 Bugs</a></li>
              
            </ul>
        </ul>
      </nav>

      <article class="box">
        
  
  
    <pre class="entry"><span class="line"></span><br /><span class="line"><span class="ngu">Int 21 Fn 4402  U - Qualitas 386max V6.00+ - Ioctl Input - Get State     </span>  [<span class="ngb">m</span>]</span><br /><span class="line"></span><br /><span class="line">   AX = 4402h</span><br /><span class="line">   BX = file handle for device &#34;386MAX$$&#34;</span><br /><span class="line">   CX = number of bytes to read</span><br /><span class="line">   DS:DX -&gt; BYTE 03h followed by 386MAX state buffer (see #1154)</span><br /><span class="line"></span><br /><span class="line"><span class="ngb">Return:</span> CF clear if successful</span><br /><span class="line">       buffer at DS:DX+1 filled</span><br /><span class="line">       AX = number of bytes actually copied</span><br /><span class="line">   CF set on error</span><br /><span class="line">       AX = error code (01h,05h,06h,0Dh) (see #1366 at AH=59h/BX=0000h)</span><br /><span class="line"></span><br /><span class="line"><span class="ngb">Notes:</span> if the value given in CX is less than the size of the state record</span><br /><span class="line">     (5Ah for v6.01, 66h for v7.00), only a partial state record will be</span><br /><span class="line">     returned</span><br /><span class="line">   the state is 40h bytes for 386MAX (actually ASTEMM) v2.20 (&#34;386MAX$$&#34;</span><br /><span class="line">     did not exist yet, use &#34;QMMXXXX0&#34; and then &#34;EMMXXXX0&#34; instead) and</span><br /><span class="line">     56h bytes for v5.11.</span><br /><span class="line">   to invoke 386MAX API functions, push DX onto the stack, load DX with</span><br /><span class="line">     the word at offset 25h in the returned state, load all other</span><br /><span class="line">     registers as needed for the desired function, and execute an</span><br /><span class="line">     OUT DX,AL or OUT DX,AX; DX will be set to the pushed value on return</span><br /><span class="line">     if it is not otherwise modified by the API function.  For safety,</span><br /><span class="line">     in case a function is not supported or 386MAX is not present, SP</span><br /><span class="line">     should be saved and restored around the API call.</span><br /><span class="line">   Windows 3.1 Standard mode, LAN Manager, and Windows for Workgroups all</span><br /><span class="line">     use the 386MAX API; LAN Manager and Windows for Workgroups reportedly</span><br /><span class="line">     make some calls incorrectly</span><br /><span class="line"></span><br /><span class="line"><span class="ngb">See Also:</span> AX=4403h/SF=03h&#34;386MAX&#34;,INT 67/AH=3Fh</span><br /><span class="line"></span><br /><span class="line">Format of 386MAX v6.01+ state:</span><br /><span class="line">Offset Size    Description (Table 1154)</span><br /><span class="line"> -1    BYTE    (call) 03h</span><br /><span class="line"> 00h  6 BYTEs  signature &#34;386MAX&#34;</span><br /><span class="line"> 06h  4 BYTEs  version string &#34;N;NN&#34; or &#34;N.NN&#34; (i.e. &#34;6;01&#34; for v6.01)</span><br /><span class="line">       (&#39;;&#39; by default; apparently changed to a period when 386MAX</span><br /><span class="line">       has linked high RAM into DOS&#39;s memory chain)</span><br /><span class="line"> 0Ah   WORD    segment of low-memory portion of 386MAX.SYS</span><br /><span class="line"> 0Ch  2 BYTEs  ???</span><br /><span class="line"> 0Eh   WORD    segment of ??? memory block or 0000h</span><br /><span class="line"> 10h   WORD    bit flags 1 (see #1155)</span><br /><span class="line"> 12h   WORD    starting address of video memory in KB</span><br /><span class="line"> 14h  2 BYTEs  ???</span><br /><span class="line"> 16h   WORD    total high DOS memory in KB</span><br /><span class="line"> 18h  2 BYTEs  ???</span><br /><span class="line"> 1Ah   WORD    available shared memory in KB</span><br /><span class="line"> 1Ch   WORD    KBytes extended memory used by 386MAX</span><br /><span class="line"> 1Eh  2 BYTEs  ???</span><br /><span class="line"> 20h   WORD    total extended memory in KB</span><br /><span class="line"> 22h   WORD    IO port to write (OUT DX,AL) to invoke 386MAX INT 15 functions</span><br /><span class="line"> 24h   WORD    IO port to write (OUT DX,AL) to invoke 386MAX API functions</span><br /><span class="line">         (see #1168)</span><br /><span class="line"> 26h   WORD    ??? (depends on DOS version)</span><br /><span class="line"> 28h   WORD    size of ??? in paragraphs</span><br /><span class="line"> 2Ah   DWORD   machine type (see #1163)</span><br /><span class="line"> 2Eh   DWORD   -&gt; first DOS memory control block</span><br /><span class="line"> 32h   WORD    system configuration flags (see #1156)</span><br /><span class="line"> 34h   WORD    debugging flags 1 (see #1157)</span><br /><span class="line"> 36h   WORD    debugging flags 2 (see #1158)</span><br /><span class="line"> 38h  2 BYTEs  ???</span><br /><span class="line"> 3Ah   WORD    segment of first MCB in high memory chain</span><br /><span class="line"> 3Ch   WORD    feature flags 1 (see #1160)</span><br /><span class="line"> 3Eh   WORD    feature flags 2 (see #1161)</span><br /><span class="line"> 40h   WORD    feature flags 3 (see #1162)</span><br /><span class="line"> 42h   WORD    segment of first 386MAX control block??? (see #1164)</span><br /><span class="line"> 44h   WORD    amount of memory to report available on INT 15/AH=88h</span><br /><span class="line"> 46h  4 BYTEs  ???</span><br /><span class="line"> 4Ah   WORD    number of K at start of address space swapped with fast</span><br /><span class="line">         extended memory (SWAP= parameter)</span><br /><span class="line"> 4Ch  2 BYTEs  ???</span><br /><span class="line"> 4Eh   WORD    segment address of ???</span><br /><span class="line"> 50h   WORD    debugging flags 3 (see #1159)</span><br /><span class="line"> 52h   DWORD   old INT 21h</span><br /><span class="line"> 56h   DWORD   pointer to 386MAX&#39;s EMS (INT 67h) handler</span><br /><span class="line">---386MAX v7.00---</span><br /><span class="line"> 5Ah   DWORD   KB of extended memory managed by 386MAX</span><br /><span class="line"> 5Eh   DWORD   bytes of extended memory (EXT= parameter)</span><br /><span class="line"> 62h  4 BYTEs  ???</span><br /><span class="line"></span><br /><span class="line">Bitfields for 386MAX bit flags 1:</span><br /><span class="line">Bit(s) Description (Table 1155)</span><br /><span class="line"> 1 ???</span><br /><span class="line"> 2 allow A20 to be enabled/disabled???</span><br /><span class="line"> 3 ??? (cleared by calling INT 67 functions or starting MSWindows)</span><br /><span class="line"> 4 high RAM present???</span><br /><span class="line"> 5 386MAX in AUTO mode</span><br /><span class="line"> 6 386MAX enabled</span><br /><span class="line"> 7 386MAX is providing EMS services</span><br /><span class="line"> 8 ??? (affects API function 08h)</span><br /><span class="line"> 9 A20 gate closed (A20 disabled) (see INT 15/AX=2402h)</span><br /><span class="line"> 10    Weitek support enabled</span><br /><span class="line"> 11    ???</span><br /><span class="line"> 12    ROMs not shadowed???</span><br /><span class="line"> 13    QPMS has been used</span><br /><span class="line"> 14    ???</span><br /><span class="line"> 15    ???</span><br /><span class="line"></span><br /><span class="line">Bitfields for 386MAX system configuration flags:</span><br /><span class="line">Bit(s) Description (Table 1156)</span><br /><span class="line"> 1 ROM compressed???</span><br /><span class="line"> 3 ???</span><br /><span class="line"> 5 386MAX loaded into high memory</span><br /><span class="line"> 6 Microchannel bus</span><br /><span class="line"> 7 Weitek math coprocessor detected</span><br /><span class="line"> 9 ??? (also generates INT 01 on ??? and INT 03 on ???)</span><br /><span class="line"> 11    PC/XT (thus only single 8259 interrupt controller present, DMA only</span><br /><span class="line">       in 1st megabyte, etc)</span><br /><span class="line"> 13    LMLTOP= specified</span><br /><span class="line"> 14    enable A20 control???</span><br /><span class="line"> 15    ???</span><br /><span class="line"></span><br /><span class="line">Bitfields for 386MAX debugging flags 1:</span><br /><span class="line">Bit(s) Description (Table 1157)</span><br /><span class="line"> 0 DEBUG=LED</span><br /><span class="line"> 1 DEBUG=X67</span><br /><span class="line"> 2 DEBUG=INV</span><br /><span class="line"> 3 DEBUG=EMSPTED</span><br /><span class="line"> 4 DEBUG=JMP</span><br /><span class="line"> 5 DEBUG=CALL</span><br /><span class="line"> 6 DEBUG=HLT</span><br /><span class="line"> 7 DEBUG=PMR</span><br /><span class="line"> 8 DEBUG=CR3</span><br /><span class="line"> 9 DEBUG=CAPS or DEBUG=INT</span><br /><span class="line"> 10    DEBUG=RC</span><br /><span class="line"> 11    DEBUG=ROM</span><br /><span class="line"> 12    DEBUG=XM</span><br /><span class="line"> 13    DEBUG=SOR</span><br /><span class="line"> 14    DEBUG=XR</span><br /><span class="line"> 15    DEBUG=EMSERR (generate INT 01 on returning error from EMS call)</span><br /><span class="line"></span><br /><span class="line">Bitfields for 386MAX debugging flags 2:</span><br /><span class="line">Bit(s) Description (Table 1158)</span><br /><span class="line"> 0 DEBUG=ROMSWAP</span><br /><span class="line"> 1 DEBUG=UNSHADOWROM</span><br /><span class="line"> 2 DEBUG=COMPROM</span><br /><span class="line"> 3 DEBUG=DPMIPHYS</span><br /><span class="line"> 4 DEBUG=ALLROM</span><br /><span class="line"> 5 DEBUG=VMS</span><br /><span class="line"> 6 DEBUG=XMS (generate INT 01 on XMS calls)</span><br /><span class="line"> 7 DEBUG=I06</span><br /><span class="line"> 8 DEBUG=VCPI</span><br /><span class="line"> 9 DEBUG=XDMA</span><br /><span class="line"> 10    DEBUG=X09</span><br /><span class="line"> 13    DEBUG=I67 (generate INT 01 on every INT 67 call)</span><br /><span class="line"> 14    DEBUG=EVM (generate INT 01 on entering V86 mode)</span><br /><span class="line"> 15    DEBUG=EMSSAVE or DEBUG=VDS</span><br /><span class="line"></span><br /><span class="line">Bitfields for 386MAX debugging flags 3:</span><br /><span class="line">Bit(s) Description (Table 1159)</span><br /><span class="line"> 10    DEBUG=EPM</span><br /><span class="line"> 12    DEBUG=ABIOS</span><br /><span class="line"> 13    DEBUG=XMSPTED</span><br /><span class="line"> 14    DEBUG=TIME</span><br /><span class="line"> 15    DEBUG=SCRUB</span><br /><span class="line"></span><br /><span class="line">Bitfields for 386MAX feature flags 1:</span><br /><span class="line">Bit(s) Description (Table 1160)</span><br /><span class="line"> 1 Weitek present</span><br /><span class="line"> 2 no DPMI services</span><br /><span class="line"> 3 NODMA</span><br /><span class="line"> 4 TERSE</span><br /><span class="line"> 5 NOROM</span><br /><span class="line"> 6 NOPARITY</span><br /><span class="line"> 8 NOFLEX (IGNOREFLEXFRAME)</span><br /><span class="line"> 11    don&#39;t create UMBs</span><br /><span class="line"> 12    don&#39;t backfill below video memory (NOLOW)</span><br /><span class="line"> 13    FRAME= specified</span><br /><span class="line"> 14    EXT= specified</span><br /><span class="line"> 15    NOEMS, allow prior expanded memory manager to provide EMS</span><br /><span class="line"></span><br /><span class="line">Bitfields for 386MAX feature flags 2:</span><br /><span class="line">Bit(s) Description (Table 1161)</span><br /><span class="line"> 0 UNSHIFT specified (FORCEA20 disabled)</span><br /><span class="line"> 1 NOXRAM</span><br /><span class="line"> 2 NOSCSI specified</span><br /><span class="line"> 3 SCREEN specified</span><br /><span class="line"> 4 enabled EISADMA</span><br /><span class="line"> 5 slow DMA</span><br /><span class="line"> 6 RESETKEYB specified</span><br /><span class="line"> 7 ???</span><br /><span class="line"> 9 TOP384</span><br /><span class="line"> 10    ???</span><br /><span class="line"> 11    NOWARMBOOT</span><br /><span class="line"> 12    USE= specified</span><br /><span class="line"> 13    ROM= specified</span><br /><span class="line"></span><br /><span class="line">Bitfields for 386MAX feature flags 3:</span><br /><span class="line">Bit(s) Description (Table 1162)</span><br /><span class="line"> 0 Windows3 support enabled</span><br /><span class="line"> 1 SHADOWROM</span><br /><span class="line"> 2 don&#39;t compress ROM (NOCOMPROM)</span><br /><span class="line"> 3 ??? (related to PRGREG=)</span><br /><span class="line"> 4 ??? (related to PRGREG=)</span><br /><span class="line"> 5 SHADOWRAM</span><br /><span class="line"> 6 DOS4 specified</span><br /><span class="line"> 7 NOLOADHIGH</span><br /><span class="line"> 8 NOPULSE</span><br /><span class="line"> 11    FORCEA20</span><br /><span class="line"> 12    DMA buffer enabled</span><br /><span class="line"> 13    NOSCRUB</span><br /><span class="line"> 15    NOFRAME</span><br /><span class="line"></span><br /><span class="line">Bitfields for 386MAX machine type:</span><br /><span class="line">Bit(s) Description (Table 1163)</span><br /><span class="line"> 12    Amstrad</span><br /><span class="line"> 13    Epson</span><br /><span class="line"> 14    Zenith Data Systems</span><br /><span class="line"> 15    &#34;ASEM&#34;</span><br /><span class="line"> 16    NEC</span><br /><span class="line"> 17    &#34;HPRS&#34; model codes 69h and 6Ah</span><br /><span class="line"> 18    Dell</span><br /><span class="line"> 19    &#34;CA&#34;</span><br /><span class="line"> 20    ITT (Xtra Business Systems/Alcatel)</span><br /><span class="line"> 21    Toshiba 5100</span><br /><span class="line"> 22    Olivetti</span><br /><span class="line"> 23    Quadram Quad386 (BIOS model FEh, submodel A6h)</span><br /><span class="line"> 24    Tandy???</span><br /><span class="line"> 25    AST 386</span><br /><span class="line"> 26    INBOARD, ??? version</span><br /><span class="line"> 27    INBOARD, ??? version</span><br /><span class="line"> 28    INBOARD, ??? version</span><br /><span class="line"> 29    &#34;HPRS&#34;</span><br /><span class="line"> 30    Compaq 386</span><br /><span class="line"> 31    JET386</span><br /><span class="line"></span><br /><span class="line">Format of 386MAX control block:</span><br /><span class="line">Offset Size    Description (Table 1164)</span><br /><span class="line"> 00h   WORD    segment of next block (FFFFh if last)</span><br /><span class="line"> 02h   WORD    segment of previous block (FFFFh if first)</span><br /><span class="line"> 04h 12 BYTEs  filename</span><br /><span class="line"> 10h   WORD    resident size in paragraphs</span><br /><span class="line"> 12h   WORD    environment size???</span><br /><span class="line"> 14h   WORD    real prsent environment size + 1 (0000h if ENVSAVE used)</span><br /><span class="line"> 16h  2 BYTEs  ???</span><br /><span class="line"> 18h   DWORD   initial size or SIZE=n in 386LOAD commandline</span><br /><span class="line"> 1Ch   DWORD   SIZE=-1 ???</span><br /><span class="line"> 20h   DWORD   SIZE= ???</span><br /><span class="line"> 24h   BYTE    PRGREG= if specified, else FFh</span><br /><span class="line"> 25h   BYTE    ENVREG= if specified, else FFh</span><br /><span class="line"> 26h   BYTE    FlexFrame (00h not present, 01h present)</span><br /><span class="line"> 27h  3 BYTEs  ???</span><br /><span class="line"> 2Ah   BYTE    GROUP= or 00h if not present</span><br /><span class="line"> 2Bh   BYTE    ???</span><br /><span class="line"> 2Ch   WORD    PSP</span><br /><span class="line"></span><br /><span class="line">Format of 386MAX high memory info record:</span><br /><span class="line">Offset Size    Description (Table 1165)</span><br /><span class="line"> 00h   WORD    segment address of memory region</span><br /><span class="line"> 02h   WORD    size of memory region in paragraphs</span><br /><span class="line"> 04h   BYTE    type or flags???</span><br /><span class="line">       00h if locked out</span><br /><span class="line">       02h if EMS page frame</span><br /><span class="line">       04h if high RAM</span><br /><span class="line">       42h if ROM</span><br /><span class="line"> 05h   BYTE    ???</span><br /><span class="line"></span><br /><span class="line">Format of 386MAX ROM shadowing record:</span><br /><span class="line">Offset Size    Description (Table 1166)</span><br /><span class="line"> 00h   WORD    logical start segment of ROM??? (may be used by BlueMAX when it</span><br /><span class="line">         squeezes together the ROMs to make room)</span><br /><span class="line"> 02h   WORD    physical start segment of ROM</span><br /><span class="line"> 04h  2 BYTEs  ???</span><br /><span class="line"> 06h   WORD    size of shadowed ROM in paragraphs</span><br /><span class="line"> 08h  2 BYTEs  ???</span><br /><span class="line"> 0Ah   WORD    flags</span><br /><span class="line">       bit 15: shadowing enabled for this ROM???</span><br /><span class="line">       bit 14: ???</span><br /><span class="line">       bit 13: ???</span><br /><span class="line">       bit 12: ???</span><br /><span class="line">       bit 10: ???</span><br /><span class="line"></span><br /><span class="line">(Table 1167)</span><br /><span class="line">Values for 386MAX memory type:</span><br /><span class="line"> 00h   unused by EMS</span><br /><span class="line"> 01h   DOS</span><br /><span class="line"> 04h   page frame overlapping ROM???</span><br /><span class="line"> 80h   high memory</span><br /><span class="line"> 84h   page frame???</span><br /><span class="line"> 87h   video ROM???</span><br /><span class="line"></span><br /><span class="line"><span class="ngb">Note:</span>  the type may be 00h (unused) if the 16K page is split among different</span><br /><span class="line">     uses (such as ROM and high RAM)</span><br /><span class="line"></span><br /><span class="line">(Table 1168)</span><br /><span class="line">Call 386MAX API (via OUT DX,AL) with:</span><br /><span class="line">   STACK: WORD value for DX</span><br /><span class="line">   AH = 00h unused</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> AH = 84h (unsupported function)</span><br /><span class="line">   AH = 01h get high memory information</span><br /><span class="line">       ES:DI -&gt; buffer for array of high memory info records</span><br /><span class="line">           (see #1165)</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> CX = number of records placed in buffer</span><br /><span class="line">   AH = 02h get shadowed ROM info</span><br /><span class="line">       ES:DI -&gt; buffer for array of ROM shadowing records (see #1166)</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> CX = number of records placed in buffer</span><br /><span class="line">   AH = 03h get 386MAX state</span><br /><span class="line">       ES:DI -&gt; 90-byte buffer for state (see #1154)</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> AH = 00h (successful)</span><br /><span class="line">           buffer filled</span><br /><span class="line">   AH = 04h get memory types???</span><br /><span class="line">       ES:DI -&gt; buffer for memory type info (array of bytes, one per</span><br /><span class="line">           16K page) (see #1167)</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> CX = number of bytes placed in buffer</span><br /><span class="line">   AH = 05h get page table entries</span><br /><span class="line">       AL = A20 control (00h enable A20 first, 01h leave unchanged)</span><br /><span class="line">       CX = buffer size in bytes (0000h = enough for all memory from</span><br /><span class="line">           given start to end of memory managed by 386MAX)</span><br /><span class="line">       SI = first K to report (rounded down to 4K page)</span><br /><span class="line">       ES:DI -&gt; buffer for returned page table entries</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> CX = number of bytes returned (four per 4K page)</span><br /><span class="line">           ES:DI buffer filled</span><br /><span class="line">   AH = 06h get memory speed info</span><br /><span class="line">       ES:DI -&gt; buffer for memory speed records (see #1169)</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> AH = 00h (successful)</span><br /><span class="line">           CX = number of bytes placed in buffer</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Note:</span>   this function can take over a second to execute</span><br /><span class="line">   AH = 07h map/unmap multiple handle pages</span><br /><span class="line">       DX = EMS handle (on stack)</span><br /><span class="line">       STACK: DWORD -&gt; EMS mapping record</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> AH = status (00h,80h,83h,8Ah,8Bh)</span><br /><span class="line">       Format of EMS mapping record:</span><br /><span class="line">       Offset  Size    Description</span><br /><span class="line">        00h    WORD    function</span><br /><span class="line">               0000h use physical page numbers</span><br /><span class="line">               0001h use segment addresses</span><br /><span class="line">        02h    WORD    EMS handle</span><br /><span class="line">        04h    WORD    number of mapping entries following</span><br /><span class="line">        06h 2N WORDs   logical page number and physical page/segment</span><br /><span class="line">               logical page FFFFh means unmap physical page</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">See Also:</span> INT 67/AH=50h</span><br /><span class="line">   AH = 08h &#34;EMM2_GOREAL&#34; check whether possible to disable 386MAX</span><br /><span class="line">       AL = ??? (00h or nonzero)</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> AH = status (00h OK, A4h not possible at this time)</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Note:</span>   if AL=00h, this function always returns success</span><br /><span class="line">   AH = 09h toggle Bit Flags 1 flags</span><br /><span class="line">       BX = bitmask of bit flags 1&#39;s flags to toggle (see #1155)</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> AH = 00h (successful)</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Note:</span>   enables A20 first</span><br /><span class="line">   AH = 0Ah toggle Debugging Flags 1 flags</span><br /><span class="line">       BX = bitmask of Debugging Flags 1&#39;s bits to toggle (see #1157)</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> AH = 00h (successful)</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Notes:</span>  enables A20 first</span><br /><span class="line">           does ??? if bit 3 on after specified bits are toggled</span><br /><span class="line">   AH = 0Bh toggle Debugging Flags 2 flags</span><br /><span class="line">       BX = bitmask of Debugging Flags 2&#39;s bits to toggle (see #1158)</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Return:</span> AH = 00h (successful)</span><br /><span class="line"></span><br /><span class="line">       <span class="ngb">Note:</span>   enables A20 first</span><br /><span class="line">   AH = 0Ch toggle feature flags 3</span><br /><span class="line">       BX = bitmask of feature flags 3&#39;s bits to toggle (see #1162)</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line"><span class="ngb">.NG limit reached, continued in next section...</span></span><br /></pre>
  
  
  


      </article>

    </section>

  </body>

</html>

