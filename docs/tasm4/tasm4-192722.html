





<!DOCTYPE html>
<html>

  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <meta name="generator" content="ng2web v1.1.0 (ngdb v1.1.0)">
    <link rel="stylesheet" type="text/css" href="tasm4-style.css">
    <title>TASM v4.0 » Assembler » Symbols &amp; expressions</title>
    <meta name="description" content="TASM v4.0">
    <link rel="prev" href="tasm4-190309.html">
    <link rel="next" href="tasm4-196480.html">
    
  </head>

  <body>

    <header>
      <nav class="box">
        <ul>
          

<li><a href="tasm4-about.html">About</a></li>


          

<li><a href="tasm4-190309.html">Previous</a></li>


          

<li><a href="tasm4-189366.html">Up</a></li>


          

<li><a href="tasm4-196480.html">Next</a></li>


        </ul>
      </nav>
    </header>

    <section>

      <nav class="menu box">
        <ul>
            <li>Assembler</li>
            <ul>
              <li><a href="index.html">Directives</a></li>
              <li><a href="tasm4-124679.html">Operators</a></li>
              <li><a href="tasm4-151581.html">Predefined equates</a></li>
              <li><a href="tasm4-160592.html">Command line</a></li>
              <li><a href="tasm4-189366.html">Symbols &amp; expressions</a></li>
              <li><a href="tasm4-202140.html">Interfacing</a></li>
              <li><a href="tasm4-209306.html">Keywords</a></li>
              <li><a href="tasm4-212771.html">Error messages</a></li>
              
            </ul>
        </ul>
      </nav>

      <article class="box">
        
  
  
    <pre class="entry"><span class="line"><span class="ngb">Address subtypes</span></span><br /><span class="line"></span><br /><span class="line">    Symbol subtypes describe whether the symbol represents the address of</span><br /><span class="line">    a byte, a word, and so forth. The following tables show the simple and</span><br /><span class="line">    complex address subtypes that Turbo Assembler provides:</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">  <span class="ngb">Simple address subtypes</span></span><br /><span class="line"></span><br /><span class="line">    <span class="ngb">Type expression     Meaning</span></span><br /><span class="line">    ───────────────────────────────────────────────────────────────────</span><br /><span class="line">    UNKNOWN             Unknown or undetermined address subtype</span><br /><span class="line">    BYTE                Address describes a byte</span><br /><span class="line">    WORD                Address describes a word</span><br /><span class="line">    DWORD               Address describes a 4-byte quantity</span><br /><span class="line">    PWORD or FWORD      Address describes a 6-byte quantity</span><br /><span class="line">    QWORD               Address describes an 8-byte quantity</span><br /><span class="line">    TBYTE               Address describes a 10-byte quantity</span><br /><span class="line">    SHORT               Address describes a short label/procedure address</span><br /><span class="line">    NEAR                Address describes a near label/procedure address</span><br /><span class="line">    FAR                 Address describes a far label/procedure address</span><br /><span class="line">    PROC                Address describes either a near or far label/</span><br /><span class="line">                        procedure address, depending on the currently</span><br /><span class="line">                        selected programming model (memory model)</span><br /><span class="line">    DATAPTR             Address describes either a word, dword, or pword</span><br /><span class="line">                        quantity, depending on the currently selected</span><br /><span class="line">                        programming model</span><br /><span class="line">    CODEPTR             Address describes either a word, dword, or pword</span><br /><span class="line">                        quantity, depending on the currently selected</span><br /><span class="line">                        programming model</span><br /><span class="line">    strucname/unionname Address describes an instance of the named structure</span><br /><span class="line">                        or union</span><br /><span class="line">    tablename           Address describes an instance of the named table</span><br /><span class="line">    recordname          Address describes an instance of the named record;</span><br /><span class="line">                        either a byte, word, or dword quantity</span><br /><span class="line">    enumname            Address describes an instance of the named enumerated</span><br /><span class="line">                        data type; either a byte, word, or dword quantity</span><br /><span class="line">    typename            Address describes an instance of the named type</span><br /><span class="line">                        (cf. TYPEDEF directive)</span><br /><span class="line">    TYPE expression     Address describes an item whose subtype is the</span><br /><span class="line">                        address subtype of the expression (<span class="ngb">Ideal mode only</span>)</span><br /><span class="line">    proctypename        Address describes procedure of proctype (cf. PROCTYPE</span><br /><span class="line">                        directive)</span><br /><span class="line"></span><br /><span class="line">  ───────────────────────────────────────────────────────────────────────────</span><br /><span class="line">  <span class="ngb">Complex address subtypes</span></span><br /><span class="line"></span><br /><span class="line">    Several directives (e.g. ARG, LOCAL) let you declare and use complex</span><br /><span class="line">    address subtypes. These type expressions are similar to C in that they</span><br /><span class="line">    can represent multiple levels of pointer indirection, for example, the</span><br /><span class="line">    complex type expression</span><br /><span class="line"></span><br /><span class="line">        PTR WORD</span><br /><span class="line"></span><br /><span class="line">    represents a pointer to a word. (The size of the pointer depends on</span><br /><span class="line">    the segmentation model you selected with the MODEL directive.) The</span><br /><span class="line">    following table shows a syntax summary of <span class="ngb">complex address subtypes:</span></span><br /><span class="line"></span><br /><span class="line">    <span class="ngb">Syntax                                    Meaning</span></span><br /><span class="line">    ───────────────────────────────────────────────────────────────────────</span><br /><span class="line">    simple_address_subtype                    The specified address subtype</span><br /><span class="line"></span><br /><span class="line">    [distance] PTR [complex_address_subtype]  A pointer to the specified</span><br /><span class="line">                                              complex address subtype, the</span><br /><span class="line">                                              size of which is determined</span><br /><span class="line">                                              by the current MODEL or by</span><br /><span class="line">                                              the specified distance, if</span><br /><span class="line">                                              present</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">    You can describe the optional <span class="ngb">distance</span> parameter in the following ways:</span><br /><span class="line"></span><br /><span class="line">    <span class="ngb">Syntax              Meaning</span></span><br /><span class="line">    ───────────────────────────────────────────────────────────────────────</span><br /><span class="line">    NEAR                Use a near pointer; can be either 16 or 32 bits,</span><br /><span class="line">                        depending on the current MODEL</span><br /><span class="line">    FAR                 Use a far pointer; can be either 32 or 48 bits,</span><br /><span class="line">                        depending on the current MODEL</span><br /><span class="line">    SMALL NEAR          Use a 16-bit pointer; ≥80386 only</span><br /><span class="line">    LARGE NEAR          Use a 32-bit near pointer; ≥80386 only</span><br /><span class="line">    SMALL FAR           Use a 32-bit far pointer; ≥80386 only</span><br /><span class="line">    LARGE FAR           Use a 48-bit far pointer; ≥80386 only</span><br /><span class="line"></span><br /><span class="line">    The type of the object being pointed to is not strictly required in</span><br /><span class="line">    complex pointer types; Turbo Assembler only needs to know the size of</span><br /><span class="line">    the type. Therefore, forward references are permitted in complex pointer</span><br /><span class="line">    types (but not in simple types).</span><br /></pre>
  
  
  
    <nav class="seeAlso">
      <ul>
        <li>See Also:</li>
        
          <li><a href="tasm4-65434.html">MODEL</a></li>
        
          <li><a href="tasm4-111272.html">TYPEDEF</a></li>
        
          <li><a href="tasm4-83038.html">PROCTYPE</a></li>
        
          <li><a href="tasm4-143023.html">PTR</a></li>
        
          <li><a href="tasm4-13568.html">ARG</a></li>
        
          <li><a href="tasm4-146921.html">SMALL</a></li>
        
          <li><a href="tasm4-138950.html">LARGE</a></li>
        
          <li><a href="tasm4-150191.html">UNKNOWN</a></li>
        
          <li><a href="tasm4-201286.html">ABS</a></li>
        
      </ul>
    </nav>
  


      </article>

    </section>

  </body>

</html>

