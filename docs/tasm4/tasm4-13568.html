





<!DOCTYPE html>
<html>

  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <meta name="generator" content="ng2web v1.1.0 (ngdb v1.1.0)">
    <link rel="stylesheet" type="text/css" href="tasm4-style.css">
    <title>TASM v4.0 » Assembler » Directives</title>
    <meta name="description" content="TASM v4.0">
    <link rel="prev" href="tasm4-13119.html">
    <link rel="next" href="tasm4-18252.html">
    
  </head>

  <body>

    <header>
      <nav class="box">
        <ul>
          

<li><a href="../index.html">Guides</a></li>


          

<li><a href="tasm4-about.html">About</a></li>


          

<li><a href="tasm4-13119.html">Previous</a></li>


          

<li><a href="index.html">Up</a></li>


          

<li><a href="tasm4-18252.html">Next</a></li>


        </ul>
      </nav>
    </header>

    <section>

      <nav class="menu box">
        <ul>
            <li>Assembler</li>
            <ul>
              <li><a href="index.html">Directives</a></li>
              <li><a href="tasm4-124679.html">Operators</a></li>
              <li><a href="tasm4-151581.html">Predefined equates</a></li>
              <li><a href="tasm4-160592.html">Command line</a></li>
              <li><a href="tasm4-189366.html">Symbols &amp; expressions</a></li>
              <li><a href="tasm4-202140.html">Interfacing</a></li>
              <li><a href="tasm4-209306.html">Keywords</a></li>
              <li><a href="tasm4-212771.html">Error messages</a></li>
              
            </ul>
        </ul>
      </nav>

      <article class="box">
        
  
  
    <pre class="entry"><span class="line"><span class="ngb">ARG              Set up argument stack                              Directive</span></span><br /><span class="line"></span><br /><span class="line">  <span class="ngb">ARG</span> argument [,argument] ... [=symbol] [RETURNS argument [,argument]]</span><br /><span class="line"></span><br /><span class="line">    Sets up arguments on the stack for procedures. Each argument is</span><br /><span class="line">    assigned a positive offset from the BP (EBP) register, presuming that</span><br /><span class="line">    both the return address of the procedure call and the caller&#39;s BP have</span><br /><span class="line">    been pushed onto the stack already.</span><br /><span class="line"></span><br /><span class="line">    The procedure&#39;s language convention determines whether or not the</span><br /><span class="line">    arguments will be assigned in reverse order on the stack. You should</span><br /><span class="line">    always list arguments in the ARG statement in the same order they</span><br /><span class="line">    would appear in a high-level language declaration of the procedure.</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">    Example:    proc func1 near</span><br /><span class="line">                arg     A:word, B:dword:2, C:byte = D</span><br /><span class="line">                local   @@x:dword, @@y:word:2     = @@z</span><br /><span class="line"></span><br /><span class="line">                defines A as [BP+4], B as [BP+6], C as [BP+14], and</span><br /><span class="line">                D as 12; @@x is [BP-2], @@y is [BP-6], and @@z is 8.</span><br /><span class="line"></span><br /><span class="line">    If you end the argument list with an equal sign (=) and a symbol, that</span><br /><span class="line">    symbol will be equated to the total size of the argument block in</span><br /><span class="line">    bytes.</span><br /><span class="line"></span><br /><span class="line">    Note that byte-sized arguments are considered to take 2 bytes of stack</span><br /><span class="line">    space, unless an explicit count field is specified.</span><br /><span class="line"></span><br /><span class="line">    All argument names (whether passed arguments (ARG), returned arguments</span><br /><span class="line">    (RETURNS), or local variables (LOCAL)) are <span class="ngb">global</span> in scope, unless you</span><br /><span class="line">    give them names prepended with the local symbol prefix.</span><br /><span class="line"></span><br /><span class="line">    ──────────────────────────────────────────────────────────────────────</span><br /><span class="line"></span><br /><span class="line">    The optional RETURNS keyword introduces one or more arguments that</span><br /><span class="line">    won&#39;t be popped from the stack when the procedure returns to its</span><br /><span class="line">    caller. Normally, if you specify the language as PASCAL or TPASCAL when</span><br /><span class="line">    using the MODEL directive, all arguments are popped when the procedure</span><br /><span class="line">    returns. The RETURNS keyword generates BP-relative equates following</span><br /><span class="line">    the C calling convention even if a procedure has a Pascal language</span><br /><span class="line">    modifier. If RETURNS is used without ARG or LOCAL, the stack frame</span><br /><span class="line">    isn&#39;t set up.</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">    Example:    ; Pascal declaration:</span><br /><span class="line">                ; Function FillChar(len:word; khar:byte) : string; external</span><br /><span class="line">                procdesc FillChar pascal far :word, :byte, :dword</span><br /><span class="line">                proc FillChar</span><br /><span class="line">                arg len:word, khar:byte  returns result_ptr:dword</span><br /><span class="line">                        les     di,[result_ptr] ; Passed by TP</span><br /><span class="line">                        mov     ax,[len]</span><br /><span class="line">                        sub     ah,ah           ; String limit = 255</span><br /><span class="line">                        cld</span><br /><span class="line">                        stosb                   ; Store length byte</span><br /><span class="line">                        mov     cx,ax</span><br /><span class="line">                        mov     al,[khar]</span><br /><span class="line">                        rep     stosb           ; Fill string</span><br /><span class="line">                        RET                     ; I.e. RETF 4</span><br /><span class="line">                endp</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">    Example:    procdesc qtest pascal :dword</span><br /><span class="line">                proc qtest</span><br /><span class="line">                arg returns @@pt:dword</span><br /><span class="line">                local dummy :word       ; Need this to set up BP</span><br /><span class="line">                ;...                    ;   correctly (generate</span><br /><span class="line">                                        ;   enter/leave)</span><br /><span class="line"></span><br /><span class="line">    ──────────────────────────────────────────────────────────────────────</span><br /><span class="line"></span><br /><span class="line">    Example:    ideal</span><br /><span class="line">                p186</span><br /><span class="line">                model   small, nolanguage</span><br /><span class="line">                codeseg</span><br /><span class="line">                proc picklist <span class="ngu">Pascal</span> near  ; Frame after ENTERing proc</span><br /><span class="line">                arg     ztitle_ptr :dword, \    [bp + 0Eh]</span><br /><span class="line">                        zlist_ptr  :dword, \    [bp + 0Ah]</span><br /><span class="line">                        num_items  :word,  \    [bp + 08h]</span><br /><span class="line">                        upper_left :word,  \    [bp + 06h]</span><br /><span class="line">                        max_width  :word   \    [bp + 04h]</span><br /><span class="line">                returns top_item  :word,   \    [bp + 12h] ; (*)</span><br /><span class="line">                        pick_item :word    ;    [bp + 14h]</span><br /><span class="line">                local   saved_csr :word,   \    [bp - 04h]</span><br /><span class="line">                        bar_pos   :word    ;    [bp - 02h]</span><br /><span class="line">                uses    ds                 ;   ([bp + 02h] = saved IP)</span><br /><span class="line">                        ASSUME ds:dgroup   ;   ([bp]       = saved BP)</span><br /><span class="line">                        ;...</span><br /><span class="line">                        RET                ; I.e. RETN 0Eh</span><br /><span class="line">                endp</span><br /><span class="line">                ;...</span><br /><span class="line">                ; Calling from assembler:</span><br /><span class="line">                push    [picked_item]      ; Push VAR parameters</span><br /><span class="line">                push    [first_item]</span><br /><span class="line">                call    picklist Pascal, \</span><br /><span class="line">                        ds dx,  \</span><br /><span class="line">                        es di,  \</span><br /><span class="line">                        [items],\</span><br /><span class="line">                        [ul],   \</span><br /><span class="line">                        [zwidth]</span><br /><span class="line">                pop     [first_item]       ; Clean up stack</span><br /><span class="line">                pop     [picked_item]      ;   and update variables</span><br /><span class="line">                ;...</span><br /><span class="line"></span><br /><span class="line">                (*) Note that RETURNS parameters are always</span><br /><span class="line">                    assigned &#34;C-style&#34; BP-relative offsets.</span><br /><span class="line"></span><br /><span class="line">    ──────────────────────────────────────────────────────────────────────</span><br /><span class="line"></span><br /><span class="line">    Similar example using C language modifier:</span><br /><span class="line"></span><br /><span class="line">                ideal</span><br /><span class="line">                p186</span><br /><span class="line">                model   small, nolanguage</span><br /><span class="line">                codeseg</span><br /><span class="line">                proc picklist <span class="ngu">C</span> near       ; Frame after ENTERing proc</span><br /><span class="line">                arg     ztitle_ptr :dword, \    [bp + 04h]</span><br /><span class="line">                        zlist_ptr  :dword, \    [bp + 08h]</span><br /><span class="line">                        num_items  :word,  \    [bp + 0Ch]</span><br /><span class="line">                        upper_left :word,  \    [bp + 0Eh]</span><br /><span class="line">                        max_width  :word   \    [bp + 10h]</span><br /><span class="line">                returns top_item  :word,   \    [bp + 12h] ; (*)</span><br /><span class="line">                        pick_item :word    ;    [bp + 14h]</span><br /><span class="line">                local   saved_csr :word,   \    [bp - 02h]</span><br /><span class="line">                        bar_pos   :word    ;    [bp - 04h]</span><br /><span class="line">                uses    ds,si,di           ;   ([bp + 02h] = saved IP)</span><br /><span class="line">                        ASSUME ds:dgroup   ;   ([bp]       = saved BP)</span><br /><span class="line">                        ;...</span><br /><span class="line">                        RET                ; I.e. RETN 00h</span><br /><span class="line">                endp</span><br /><span class="line">                ;...</span><br /><span class="line">                ; Calling from assembler:</span><br /><span class="line">                push    [picked_item]      ; Push VAR parameters</span><br /><span class="line">                push    [first_item]</span><br /><span class="line">                call    picklist C, \</span><br /><span class="line">                        ds dx,  \</span><br /><span class="line">                        es di,  \</span><br /><span class="line">                        [items],\</span><br /><span class="line">                        [ul],   \</span><br /><span class="line">                        [zwidth]</span><br /><span class="line">                pop     [first_item]       ; Clean up stack</span><br /><span class="line">                pop     [picked_item]      ;   and update variables</span><br /><span class="line">                ;...                       ; (TASM auto-generates</span><br /><span class="line">                                           ;  ADD SP,0Eh after CALL)</span><br /></pre>
  
  
  
    <nav class="seeAlso">
      <ul>
        <li>See Also:</li>
        
          <li><a href="tasm4-79890.html">PROC</a></li>
        
          <li><a href="tasm4-60329.html">LOCAL</a></li>
        
          <li><a href="tasm4-113153.html">USES</a></li>
        
          <li><a href="tasm4-89841.html">RET</a></li>
        
          <li><a href="tasm4-19677.html">CALL</a></li>
        
          <li><a href="tasm4-61122.html">LOCALS</a></li>
        
          <li><a href="tasm4-199535.html">Syntax</a></li>
        
          <li><a href="tasm4-202361.html">Language</a></li>
        
          <li><a href="tasm4-157301.html">@Interface</a></li>
        
      </ul>
    </nav>
  


      </article>

    </section>

  </body>

</html>

