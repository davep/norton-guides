





<!DOCTYPE html>
<html>

  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <meta name="generator" content="ng2web v1.1.0 (ngdb v1.1.0)">
    <link rel="stylesheet" type="text/css" href="perl-style.css">
    <title>PERL 4.0 Reference Guide » PERL » Languages</title>
    <meta name="description" content="PERL 4.0 Reference Guide">
    <link rel="prev" href="perl-126256.html">
    <link rel="next" href="perl-132653.html">
    
  </head>

  <body>

    <header>
      <nav class="box">
        <ul>
          

<li><a href="perl-about.html">About</a></li>


          

<li><a href="perl-126256.html">Previous</a></li>


          

<li><a href="perl-90961.html">Up</a></li>


          

<li><a href="perl-132653.html">Next</a></li>


        </ul>
      </nav>
    </header>

    <section>

      <nav class="menu box">
        <ul>
            <li>PERL</li>
            <ul>
              <li><a href="index.html">Commands</a></li>
              <li><a href="perl-90961.html">Languages</a></li>
              <li><a href="perl-159711.html">Command line options</a></li>
              <li><a href="perl-170094.html">Regular Expressions</a></li>
              <li><a href="perl-171332.html">Special Variables</a></li>
              <li><a href="perl-188582.html">Operators</a></li>
              <li><a href="perl-197905.html">Debugging</a></li>
              
            </ul>
            <li>Tables</li>
            <ul>
              <li><a href="perl-204383.html">ASCII Chart</a></li>
              <li><a href="perl-207014.html">Literals</a></li>
              <li><a href="perl-207867.html">Credits</a></li>
              
            </ul>
        </ul>
      </nav>

      <article class="box">
        
  
  
    <pre class="entry"><span class="line"></span><br /><span class="line">     Regular Expressions</span><br /><span class="line"></span><br /><span class="line">     The patterns used in pattern matching  are  regular  expres-</span><br /><span class="line">     sions  such  as  those supplied in the Version 8 regexp rou-</span><br /><span class="line">     tines.  (In  fact,  the  routines  are  derived  from  Henry</span><br /><span class="line">     Spencer&#39;s  freely redistributable reimplementation of the V8</span><br /><span class="line">     routines.)  In addition, \w matches an alphanumeric  charac-</span><br /><span class="line">     ter  (including  &#34;_&#34;)  and \W a nonalphanumeric.  Word boun-</span><br /><span class="line">     daries may be matched by \b, and non-boundaries  by  \B.   A</span><br /><span class="line">     whitespace character is matched by \s, non-whitespace by \S.</span><br /><span class="line">     A numeric character is matched by  \d,  non-numeric  by  \D.</span><br /><span class="line">     You  may  use \w, \s and \d within character classes.  Also,</span><br /><span class="line">     \n, \r, \f, \t and \NNN have their  normal  interpretations.</span><br /><span class="line">     Within character classes \b represents backspace rather than</span><br /><span class="line">     a word boundary.  Alternatives may be separated by  |.   The</span><br /><span class="line">     bracketing construct ( ... ) may also be used, in which case</span><br /><span class="line">     \&lt;digit&gt; matches the digit&#39;th substring.   (Outside  of  the</span><br /><span class="line">     pattern,  always  use  $ instead of \ in front of the digit.</span><br /><span class="line">     The scope of $&lt;digit&gt; (and $`, $&amp; and $&#39;) extends to the end</span><br /><span class="line">     of  the  enclosing BLOCK or eval string, or to the next pat-</span><br /><span class="line">     tern match with subexpressions.  The \&lt;digit&gt; notation some-</span><br /><span class="line">     times  works  outside the current pattern, but should not be</span><br /><span class="line">     relied upon.)  You may have as many parentheses as you wish.</span><br /><span class="line">     If  you have more than 9 substrings, the variables $10, $11,</span><br /><span class="line">     ... refer to the corresponding substring.  Within  the  pat-</span><br /><span class="line">     tern,  \10, \11, etc. refer back to substrings if there have</span><br /><span class="line">     been at least that many left parens  before  the  backrefer-</span><br /><span class="line">     ence.  Otherwise (for backward compatibilty) \10 is the same</span><br /><span class="line">     as \010, a backspace, and \11 the same as \011, a tab.   And</span><br /><span class="line">     so on.  (\1 through \9 are always backreferences.)</span><br /><span class="line"></span><br /><span class="line">     $+ returns whatever the  last  bracket  match  matched.   $&amp;</span><br /><span class="line">     returns  the  entire matched string.  ($0 used to return the</span><br /><span class="line">     same thing, but not any more.)  $` returns everything before</span><br /><span class="line">     the matched string.  $&#39; returns everything after the matched</span><br /><span class="line">     string.  Examples:</span><br /><span class="line"></span><br /><span class="line">          s/^([^ ]*) *([^ ]*)/$2 $1/;   # swap first two words</span><br /><span class="line"></span><br /><span class="line">          if (/Time: (..):(..):(..)/) {</span><br /><span class="line">               $hours = $1;</span><br /><span class="line">               $minutes = $2;</span><br /><span class="line">               $seconds = $3;</span><br /><span class="line">          }</span><br /><span class="line"></span><br /><span class="line">     By default, the ^ character is only guaranteed to  match  at</span><br /><span class="line">     the beginning of the string, the $ character only at the end</span><br /><span class="line">     (or before the newline at the end)  and  perl  does  certain</span><br /><span class="line">     optimizations  with  the assumption that the string contains</span><br /><span class="line">     only one line.  The behavior of ^ and $ on embedded newlines</span><br /><span class="line">     will  be  inconsistent.   You  may, however, wish to treat a</span><br /><span class="line">     string as a multi-line buffer, such that the  ^  will  match</span><br /><span class="line">     after any newline within the string, and $ will match before</span><br /><span class="line">     any newline.  At the cost of a little more overhead, you can</span><br /><span class="line">     do this by setting the variable $* to 1.  Setting it back to</span><br /><span class="line">     0 makes perl revert to its old behavior.</span><br /><span class="line"></span><br /><span class="line">     To facilitate  multi-line  substitutions,  the  .  character</span><br /><span class="line">     never matches a newline (even when $* is 0).  In particular,</span><br /><span class="line">     the following leaves a newline on the $_ string:</span><br /><span class="line"></span><br /><span class="line">          $_ = &lt;STDIN&gt;;</span><br /><span class="line">          s/.*(some_string).*/$1/;</span><br /><span class="line"></span><br /><span class="line">     If the newline is unwanted, try one of</span><br /><span class="line"></span><br /><span class="line">          s/.*(some_string).*\n/$1/;</span><br /><span class="line">          s/.*(some_string)[^\000]*/$1/;</span><br /><span class="line">          s/.*(some_string)(.|\n)*/$1/;</span><br /><span class="line">          chop; s/.*(some_string).*/$1/;</span><br /><span class="line">          /(some_string)/ &amp;&amp; ($_ = $1);</span><br /><span class="line"></span><br /><span class="line">     Any item of a regular expression may be followed with digits</span><br /><span class="line">     in  curly  brackets  of  the  form  {n,m}, where n gives the</span><br /><span class="line">     minimum number of times to match the item and  m  gives  the</span><br /><span class="line">     maximum.   The  form  {n} is equivalent to {n,n} and matches</span><br /><span class="line">     exactly n times.  The form {n,} matches  n  or  more  times.</span><br /><span class="line">     (If  a  curly  bracket  occurs  in  any other context, it is</span><br /><span class="line">     treated  as  a  regular  character.)   The  *  modifier   is</span><br /><span class="line">     equivalent  to {0,}, the + modifier to {1,} and the ? modif-</span><br /><span class="line">     ier to {0,1}.  There is no limit to the size of n or m,  but</span><br /><span class="line">     large numbers will chew up more memory.</span><br /><span class="line"></span><br /><span class="line">     You will note that all backslashed  metacharacters  in  perl</span><br /><span class="line">     are  alphanumeric,  such  as  \b, \w, \n.  Unlike some other</span><br /><span class="line">     regular expression languages, there are no backslashed  sym-</span><br /><span class="line">     bols  that aren&#39;t alphanumeric.  So anything that looks like</span><br /><span class="line">     \\, \(, \), \&lt;, \&gt;, \{, or \} is  always  interpreted  as  a</span><br /><span class="line">     literal  character, not a metacharacter.  This makes it sim-</span><br /><span class="line">     ple to quote a string that you want to use for a pattern but</span><br /><span class="line">     that  you  are  afraid might contain metacharacters.  Simply</span><br /><span class="line">     quote all the non-alphanumeric characters:</span><br /><span class="line"></span><br /><span class="line">          $pattern =~ s/(\W)/\\$1/g;</span><br /></pre>
  
  
  


      </article>

    </section>

  </body>

</html>

