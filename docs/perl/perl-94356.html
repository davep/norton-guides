





<!DOCTYPE html>
<html>

  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <meta name="generator" content="ng2web v1.1.0 (ngdb v1.1.0)">
    <link rel="stylesheet" type="text/css" href="perl-style.css">
    <title>PERL 4.0 Reference Guide » PERL » Languages</title>
    <meta name="description" content="PERL 4.0 Reference Guide">
    <link rel="prev" href="perl-93673.html">
    <link rel="next" href="perl-111227.html">
    
  </head>

  <body>

    <header>
      <nav class="box">
        <ul>
          

<li><a href="../index.html">Guides</a></li>


          

<li><a href="perl-about.html">About</a></li>


          

<li><a href="perl-93673.html">Previous</a></li>


          

<li><a href="perl-90961.html">Up</a></li>


          

<li><a href="perl-111227.html">Next</a></li>


        </ul>
      </nav>
    </header>

    <section>

      <nav class="menu box">
        <ul>
            <li>PERL</li>
            <ul>
              <li><a href="index.html">Commands</a></li>
              <li><a href="perl-90961.html">Languages</a></li>
              <li><a href="perl-159711.html">Command line options</a></li>
              <li><a href="perl-170094.html">Regular Expressions</a></li>
              <li><a href="perl-171332.html">Special Variables</a></li>
              <li><a href="perl-188582.html">Operators</a></li>
              <li><a href="perl-197905.html">Debugging</a></li>
              
            </ul>
            <li>Tables</li>
            <ul>
              <li><a href="perl-204383.html">ASCII Chart</a></li>
              <li><a href="perl-207014.html">Literals</a></li>
              <li><a href="perl-207867.html">Credits</a></li>
              
            </ul>
        </ul>
      </nav>

      <article class="box">
        
  
  
    <pre class="entry"><span class="line"></span><br /><span class="line">     Data Types and Objects</span><br /><span class="line"></span><br /><span class="line">     Perl has three data types: scalars, arrays of  scalars,  and</span><br /><span class="line">     associative arrays of scalars.  Normal arrays are indexed by</span><br /><span class="line">     number, and associative arrays by string.</span><br /><span class="line"></span><br /><span class="line">     The interpretation of operations and values  in  perl  some-</span><br /><span class="line">     times  depends on the requirements of the context around the</span><br /><span class="line">     operation or value.  There are three major contexts: string,</span><br /><span class="line">     numeric  and  array.  Certain operations return array values</span><br /><span class="line">     in contexts wanting an array, and scalar  values  otherwise.</span><br /><span class="line">     (If this is true of an operation it will be mentioned in the</span><br /><span class="line">     documentation for that operation.)  Operations which  return</span><br /><span class="line">     scalars  don&#39;t  care  whether  the  context is looking for a</span><br /><span class="line">     string or a number, but  scalar  variables  and  values  are</span><br /><span class="line">     interpreted as strings or numbers as appropriate to the con-</span><br /><span class="line">     text.  A scalar is interpreted as TRUE in the boolean  sense</span><br /><span class="line">     if  it  is  not  the null string or 0.  Booleans returned by</span><br /><span class="line">     operators are 1 for true and 0 or &#39;&#39; (the null  string)  for</span><br /><span class="line">     false.</span><br /><span class="line"></span><br /><span class="line">     There are actually two varieties of null string: defined and</span><br /><span class="line">     undefined.   Undefined  null strings are returned when there</span><br /><span class="line">     is no real value for something, such as when  there  was  an</span><br /><span class="line">     error, or at end of file, or when you refer to an uninitial-</span><br /><span class="line">     ized variable or element of an  array.   An  undefined  null</span><br /><span class="line">     string  may become defined the first time you access it, but</span><br /><span class="line">     prior to that you can use the defined() operator  to  deter-</span><br /><span class="line">     mine whether the value is defined or not.</span><br /><span class="line"></span><br /><span class="line">     References to scalar variables always begin with  &#39;$&#39;,  even</span><br /><span class="line">     when referring to a scalar that is part of an array.  Thus:</span><br /><span class="line"></span><br /><span class="line">         $days           # a simple scalar variable</span><br /><span class="line">         $days[28]       # 29th element of array @days</span><br /><span class="line">         $days{&#39;Feb&#39;}    # one value from an associative array</span><br /><span class="line">         $#days          # last index of array @days</span><br /><span class="line"></span><br /><span class="line">     but entire arrays or array slices are denoted by &#39;@&#39;:</span><br /><span class="line"></span><br /><span class="line">         @days           # ($days[0], $days[1],... $days[n])</span><br /><span class="line">         @days[3,4,5]    # same as @days[3..5]</span><br /><span class="line">         @days{&#39;a&#39;,&#39;c&#39;}  # same as ($days{&#39;a&#39;},$days{&#39;c&#39;})</span><br /><span class="line"></span><br /><span class="line">     and entire associative arrays are denoted by &#39;%&#39;:</span><br /><span class="line"></span><br /><span class="line">         %days           # (key1, val1, key2, val2 ...)</span><br /><span class="line"></span><br /><span class="line">     Any of these eight constructs may serve as an  lvalue,  that</span><br /><span class="line">     is,  may be assigned to.  (It also turns out that an assign-</span><br /><span class="line">     ment is itself an lvalue in certain  contexts--see  examples</span><br /><span class="line">     under s, tr and chop.)  Assignment to a scalar evaluates the</span><br /><span class="line">     righthand side in a scalar context, while assignment  to  an</span><br /><span class="line">     array  or  array  slice  evaluates  the righthand side in an</span><br /><span class="line">     array context.</span><br /><span class="line"></span><br /><span class="line">     You may  find  the  length  of  array  @days  by  evaluating</span><br /><span class="line">     &#34;$#days&#34;,  as in csh.  (Actually, it&#39;s not the length of the</span><br /><span class="line">     array, it&#39;s the subscript of the last element,  since  there</span><br /><span class="line">     is (ordinarily) a 0th element.)  Assigning to $#days changes</span><br /><span class="line">     the length of the array.  Shortening an array by this method</span><br /><span class="line">     does  not actually destroy any values.  Lengthening an array</span><br /><span class="line">     that was previously shortened recovers the values that  were</span><br /><span class="line">     in  those elements.  You can also gain some measure of effi-</span><br /><span class="line">     ciency by preextending an array that is going  to  get  big.</span><br /><span class="line">     (You  can  also  extend  an array by assigning to an element</span><br /><span class="line">     that is off the end of the array.  This differs from assign-</span><br /><span class="line">     ing to $#whatever in that intervening values are set to null</span><br /><span class="line">     rather than recovered.)  You can truncate an array  down  to</span><br /><span class="line">     nothing  by assigning the null list () to it.  The following</span><br /><span class="line">     are exactly equivalent</span><br /><span class="line"></span><br /><span class="line">          @whatever = ();</span><br /><span class="line">          $#whatever = $[ - 1;</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">     If you evaluate an array in a scalar context, it returns the</span><br /><span class="line">     length of the array.  The following is always true:</span><br /><span class="line"></span><br /><span class="line">          @whatever == $#whatever - $[ + 1;</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">     Multi-dimensional arrays are not directly supported, but see</span><br /><span class="line">     the  discussion of the $; variable later for a means of emu-</span><br /><span class="line">     lating multiple subscripts with an associative  array.   You</span><br /><span class="line">     could  also  write  a subroutine to turn multiple subscripts</span><br /><span class="line">     into a single subscript.</span><br /><span class="line"></span><br /><span class="line">     Every data type has its own  namespace.   You  can,  without</span><br /><span class="line">     fear  of  conflict, use the same name for a scalar variable,</span><br /><span class="line">     an array, an associative array, a filehandle,  a  subroutine</span><br /><span class="line">     name,  and/or  a label.  Since variable and array references</span><br /><span class="line">     always start with &#39;$&#39;, &#39;@&#39;, or  &#39;%&#39;,  the  &#34;reserved&#34;  words</span><br /><span class="line">     aren&#39;t  in  fact  reserved  with  respect to variable names.</span><br /><span class="line">     (They ARE reserved with respect to labels  and  filehandles,</span><br /><span class="line">     however,  which  don&#39;t  have  an  initial special character.</span><br /><span class="line">     Hint:  you  could  say   open(LOG,&#39;logfile&#39;)   rather   than</span><br /><span class="line">     open(log,&#39;logfile&#39;).    Using   uppercase  filehandles  also</span><br /><span class="line">     improves readability and protects  you  from  conflict  with</span><br /><span class="line">     future  reserved  words.)  Case IS significant--&#34;FOO&#34;, &#34;Foo&#34;</span><br /><span class="line">     and &#34;foo&#34; are all different names.  Names which start with a</span><br /><span class="line">     letter may also contain digits and underscores.  Names which</span><br /><span class="line">     do not start with a letter are  limited  to  one  character,</span><br /><span class="line">     e.g.  &#34;$%&#34; or &#34;$$&#34;.  (Most of the one character names have a</span><br /><span class="line">     predefined significance to perl.  More later.)</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">     You can also embed newlines directly in your  strings,  i.e.</span><br /><span class="line">     they  can  end on a different line than they begin.  This is</span><br /><span class="line">     nice, but if you forget your trailing quote, the error  will</span><br /><span class="line">     not be reported until perl finds another line containing the</span><br /><span class="line">     quote character, which may be much further on in the script.</span><br /><span class="line">     Variable  substitution  inside  strings is limited to scalar</span><br /><span class="line">     variables, normal array values, and array slices.  (In other</span><br /><span class="line">     words,  identifiers  beginning  with  $ or @, followed by an</span><br /><span class="line">     optional bracketed expression as a subscript.)  The  follow-</span><br /><span class="line">     ing code segment prints out &#34;The price is $100.&#34;</span><br /><span class="line"></span><br /><span class="line">         $Price = &#39;$100&#39;;               # not interpreted</span><br /><span class="line">         print &#34;The price is $Price.\n&#34;;# interpreted</span><br /><span class="line"></span><br /><span class="line">     Note that you can put curly brackets around  the  identifier</span><br /><span class="line">     to  delimit it from following alphanumerics.  Also note that</span><br /><span class="line">     a single quoted string must be separated  from  a  preceding</span><br /><span class="line">     word  by a space, since single quote is a valid character in</span><br /><span class="line">     an identifier (see Packages).</span><br /><span class="line"></span><br /><span class="line">     Two  special  literals  are  __LINE__  and  __FILE__,  which</span><br /><span class="line">     represent the current line number and filename at that point</span><br /><span class="line">     in your program.  They may only be used as separate  tokens;</span><br /><span class="line">     they  will  not  be interpolated into strings.  In addition,</span><br /><span class="line">     the token __END__ may be used to indicate the logical end of</span><br /><span class="line">     the  script  before  the  actual end of file.  Any following</span><br /><span class="line">     text is ignored (but may be read via the  DATA  filehandle).</span><br /><span class="line">     The  two  control  characters  ^D  and  ^Z  are synonyms for</span><br /><span class="line">     __END__.</span><br /><span class="line"></span><br /><span class="line">     A word that doesn&#39;t have any  other  interpretation  in  the</span><br /><span class="line">     grammar  will  be  treated as if it had single quotes around</span><br /><span class="line">     it.  For this purpose, a word consists only of  alphanumeric</span><br /><span class="line">     characters  and underline, and must start with an alphabetic</span><br /><span class="line">     character.  As with filehandles and labels, a bare word that</span><br /><span class="line">     consists  entirely  of lowercase letters risks conflict with</span><br /><span class="line">     future reserved words, and if you use the  -w  switch,  Perl</span><br /><span class="line">     will warn you about any such words.</span><br /><span class="line"></span><br /><span class="line">     Array values are interpolated into double-quoted strings  by</span><br /><span class="line">     joining  all  the  elements  of the array with the delimiter</span><br /><span class="line">     specified in the $&#34; variable, space by default.   (Since  in</span><br /><span class="line">     versions  of  perl  prior  to  3.0 the @ character was not a</span><br /><span class="line">     metacharacter in double-quoted strings, the interpolation of</span><br /><span class="line">     @array,   $array[EXPR],   @array[LIST],   $array{EXPR},   or</span><br /><span class="line">     @array{LIST} only happens if array is  referenced  elsewhere</span><br /><span class="line">     in  the  program  or  is  predefined.)   The  following  are</span><br /><span class="line">     equivalent:</span><br /><span class="line"></span><br /><span class="line">          $temp = join($&#34;,@ARGV);</span><br /><span class="line">          system &#34;echo $temp&#34;;</span><br /><span class="line"></span><br /><span class="line">          system &#34;echo @ARGV&#34;;</span><br /><span class="line"></span><br /><span class="line">     Within search patterns (which  also  undergo  double-quotish</span><br /><span class="line">     substitution)  there  is a bad ambiguity:  Is /$foo[bar]/ to</span><br /><span class="line">     be interpreted as /${foo}[bar]/ (where [bar] is a  character</span><br /><span class="line">     class for the regular expression) or as /${foo[bar]}/ (where</span><br /><span class="line">     [bar] is the subscript to array @foo)?  If @foo doesn&#39;t oth-</span><br /><span class="line">     erwise  exist,  then  it&#39;s  obviously a character class.  If</span><br /><span class="line">     @foo exists, perl takes a good guess  about  [bar],  and  is</span><br /><span class="line">     almost  always  right.  If it does guess wrong, or if you&#39;re</span><br /><span class="line">     just plain paranoid, you can force the  correct  interpreta-</span><br /><span class="line">     tion with curly brackets as above.</span><br /><span class="line"></span><br /><span class="line">     A line-oriented form of quoting is based on the shell  here-</span><br /><span class="line">     is syntax.  Following a &lt;&lt; you specify a string to terminate</span><br /><span class="line">     the quoted material, and all  lines  following  the  current</span><br /><span class="line">     line  down  to  the  terminating string are the value of the</span><br /><span class="line">     item.  The terminating string may be either an identifier (a</span><br /><span class="line">     word),  or  some quoted text.  If quoted, the type of quotes</span><br /><span class="line">     you use determines the treatment of the  text,  just  as  in</span><br /><span class="line">     regular  quoting.   An unquoted identifier works like double</span><br /><span class="line">     quotes.  There must be no space between the &lt;&lt; and the iden-</span><br /><span class="line">     tifier.   (If  you  put a space it will be treated as a null</span><br /><span class="line">     identifier, which is valid,  and  matches  the  first  blank</span><br /><span class="line">     line--see  Merry  Christmas example below.)  The terminating</span><br /><span class="line">     string must appear by itself (unquoted and with no surround-</span><br /><span class="line">     ing whitespace) on the terminating line.</span><br /><span class="line"></span><br /><span class="line">          print &lt;&lt;EOF;        # same as above</span><br /><span class="line">     The price is $Price.</span><br /><span class="line">     EOF</span><br /><span class="line"></span><br /><span class="line">          print &lt;&lt;&#34;EOF&#34;;      # same as above</span><br /><span class="line">     The price is $Price.</span><br /><span class="line">     EOF</span><br /><span class="line"></span><br /><span class="line">          print &lt;&lt; x 10;      # null identifier is delimiter</span><br /><span class="line">     Merry Christmas!</span><br /><span class="line"></span><br /><span class="line">          print &lt;&lt;`EOC`;      # execute commands</span><br /><span class="line">     echo hi there</span><br /><span class="line">     echo lo there</span><br /><span class="line">     EOC</span><br /><span class="line"></span><br /><span class="line">          print &lt;&lt;foo, &lt;&lt;bar; # you can stack them</span><br /><span class="line">     I said foo.</span><br /><span class="line">     foo</span><br /><span class="line">     I said bar.</span><br /><span class="line">     bar</span><br /><span class="line"></span><br /><span class="line">     Array literals are denoted by separating  individual  values</span><br /><span class="line">     by commas, and enclosing the list in parentheses:</span><br /><span class="line"></span><br /><span class="line">          (LIST)</span><br /><span class="line"></span><br /><span class="line">     In a context not requiring an array value, the value of  the</span><br /><span class="line">     array literal is the value of the final element, as in the C</span><br /><span class="line">     comma operator.  For example,</span><br /><span class="line"></span><br /><span class="line">         @foo = (&#39;cc&#39;, &#39;-E&#39;, $bar);</span><br /><span class="line"></span><br /><span class="line">     assigns the entire array value to array foo, but</span><br /><span class="line"></span><br /><span class="line">         $foo = (&#39;cc&#39;, &#39;-E&#39;, $bar);</span><br /><span class="line"></span><br /><span class="line">     assigns the value of variable bar  to  variable  foo.   Note</span><br /><span class="line">     that the value of an actual array in a scalar context is the</span><br /><span class="line">     length of the array; the following assigns to $foo the value</span><br /><span class="line">     3:</span><br /><span class="line"></span><br /><span class="line">         @foo = (&#39;cc&#39;, &#39;-E&#39;, $bar);</span><br /><span class="line">         $foo = @foo;         # $foo gets 3</span><br /><span class="line"></span><br /><span class="line">     You  may  have  an  optional  comma   before   the   closing</span><br /><span class="line">     parenthesis of an array literal, so that you can say:</span><br /><span class="line"></span><br /><span class="line">         @foo = (</span><br /><span class="line">          1,</span><br /><span class="line">          2,</span><br /><span class="line">          3,</span><br /><span class="line">         );</span><br /><span class="line"></span><br /><span class="line">     When a LIST is  evaluated,  each  element  of  the  list  is</span><br /><span class="line">     evaluated in an array context, and the resulting array value</span><br /><span class="line">     is interpolated into LIST just as if each individual element</span><br /><span class="line">     were a member of LIST.  Thus arrays lose their identity in a</span><br /><span class="line">     LIST--the list</span><br /><span class="line"></span><br /><span class="line">          (@foo,@bar,&amp;SomeSub)</span><br /><span class="line"></span><br /><span class="line">     contains all the elements of @foo followed by all  the  ele-</span><br /><span class="line">     ments  of @bar, followed by all the elements returned by the</span><br /><span class="line">     subroutine named SomeSub.</span><br /><span class="line"></span><br /><span class="line">     A list value may also be subscripted like  a  normal  array.</span><br /><span class="line">     Examples:</span><br /><span class="line"></span><br /><span class="line">          $time = (stat($file))[8];     # stat returns array value</span><br /><span class="line">          $digit = (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;)[$digit-10];</span><br /><span class="line">          return (pop(@foo),pop(@foo))[0];</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">     Array lists may be assigned to if and only if  each  element</span><br /><span class="line">     of the list is an lvalue:</span><br /><span class="line"></span><br /><span class="line">         ($a, $b, $c) = (1, 2, 3);</span><br /><span class="line"></span><br /><span class="line">         ($map{&#39;red&#39;}, $map{&#39;blue&#39;}, $map{&#39;green&#39;}) = (0x00f, 0x0f0, 0xf00);</span><br /><span class="line"></span><br /><span class="line">     The final element may be an array or an associative array:</span><br /><span class="line"></span><br /><span class="line">         ($a, $b, @rest) = split;</span><br /><span class="line">         local($a, $b, %rest) = @_;</span><br /><span class="line"></span><br /><span class="line">     You can actually put an array anywhere in the list, but  the</span><br /><span class="line">     first  array  in  the  list will soak up all the values, and</span><br /><span class="line">     anything after it will get a null value.  This may be useful</span><br /><span class="line">     in a local().</span><br /><span class="line"></span><br /><span class="line">     An associative array literal contains pairs of values to  be</span><br /><span class="line">     interpreted as a key and a value:</span><br /><span class="line"></span><br /><span class="line">         # same as map assignment above</span><br /><span class="line">         %map = (&#39;red&#39;,0x00f,&#39;blue&#39;,0x0f0,&#39;green&#39;,0xf00);</span><br /><span class="line"></span><br /><span class="line">     Array assignment in a scalar context returns the  number  of</span><br /><span class="line">     elements produced by the expression on the right side of the</span><br /><span class="line">     assignment:</span><br /><span class="line"></span><br /><span class="line">          $x = (($foo,$bar) = (3,2,1)); # set $x to 3, not 2</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">     There are several other pseudo-literals that you should know</span><br /><span class="line">     about.    If  a  string  is  enclosed  by  backticks  (grave</span><br /><span class="line">     accents), it first undergoes variable substitution just like</span><br /><span class="line">     a  double  quoted  string.  It is then interpreted as a com-</span><br /><span class="line">     mand, and the output of that command is  the  value  of  the</span><br /><span class="line">     pseudo-literal,  like  in  a  shell.  In a scalar context, a</span><br /><span class="line">     single string consisting of all the output is returned.   In</span><br /><span class="line">     an  array  context,  an array of values is returned, one for</span><br /><span class="line">     each line of output.  (You can set $/  to  use  a  different</span><br /><span class="line">     line  terminator.)   The  command  is executed each time the</span><br /><span class="line">     pseudo-literal is evaluated.  The status value of  the  com-</span><br /><span class="line">     mand  is  returned  in  $?  (see  Predefined  Names  for the</span><br /><span class="line">     interpretation of $?).  Unlike in  csh,  no  translation  is</span><br /><span class="line">     done  on  the return data--newlines remain newlines.  Unlike</span><br /><span class="line">     in any of the shells, single quotes  do  not  hide  variable</span><br /><span class="line">     names  in  the  command  from  interpretation.   To pass a $</span><br /><span class="line">     through to the shell you need to hide it with a backslash.</span><br /><span class="line"></span><br /><span class="line">     Evaluating a filehandle in angle brackets  yields  the  next</span><br /><span class="line">     line  from  that file (newline included, so it&#39;s never false</span><br /><span class="line">     until EOF, at which time an undefined  value  is  returned).</span><br /><span class="line">     Ordinarily  you  must  assign  that value to a variable, but</span><br /><span class="line">     there is one situation where an  automatic  assignment  hap-</span><br /><span class="line">     pens.   If  (and only if) the input symbol is the only thing</span><br /><span class="line">     inside the  conditional  of  a  while  loop,  the  value  is</span><br /><span class="line">     automatically assigned to the variable &#34;$_&#34;.  (This may seem</span><br /><span class="line">     like an odd thing to you, but you&#39;ll use  the  construct  in</span><br /><span class="line">     almost  every perl script you write.)  Anyway, the following</span><br /><span class="line">     lines are equivalent to each other:</span><br /><span class="line"></span><br /><span class="line">         while ($_ = &lt;STDIN&gt;) { print; }</span><br /><span class="line">         while (&lt;STDIN&gt;) { print; }</span><br /><span class="line">         for (;&lt;STDIN&gt;;) { print; }</span><br /><span class="line">         print while $_ = &lt;STDIN&gt;;</span><br /><span class="line">         print while &lt;STDIN&gt;;</span><br /><span class="line"></span><br /><span class="line">     The filehandles STDIN, STDOUT  and  STDERR  are  predefined.</span><br /><span class="line">     (The  filehandles  stdin,  stdout  and stderr will also work</span><br /><span class="line">     except in packages, where they would be interpreted as local</span><br /><span class="line">     identifiers rather than global.)  Additional filehandles may</span><br /><span class="line">     be created with the open function.</span><br /><span class="line"></span><br /><span class="line">     If a &lt;FILEHANDLE&gt; is used in a context that is  looking  for</span><br /><span class="line">     an  array,  an  array  consisting  of all the input lines is</span><br /><span class="line">     returned, one line per array element.  It&#39;s easy to  make  a</span><br /><span class="line">     LARGE data space this way, so use with care.</span><br /><span class="line"></span><br /><span class="line">     The null filehandle &lt;&gt; is special and can be used to emulate</span><br /><span class="line">     the  behavior  of  sed  and awk.  Input from &lt;&gt; comes either</span><br /><span class="line">     from standard input, or from each file listed on the command</span><br /><span class="line">     line.   Here&#39;s how it works: the first time &lt;&gt; is evaluated,</span><br /><span class="line">     the ARGV array is checked, and if it is  null,  $ARGV[0]  is</span><br /><span class="line">     set to &#39;-&#39;, which when opened gives you standard input.  The</span><br /><span class="line">     ARGV array is then processed as a list  of  filenames.   The</span><br /><span class="line">     loop</span><br /><span class="line"></span><br /><span class="line">          while (&lt;&gt;) {</span><br /><span class="line">               ...            # code for each line</span><br /><span class="line">          }</span><br /><span class="line"></span><br /><span class="line">     is equivalent to</span><br /><span class="line"></span><br /><span class="line">          unshift(@ARGV, &#39;-&#39;) if $#ARGV &lt; $[;</span><br /><span class="line">          while ($ARGV = shift) {</span><br /><span class="line">               open(ARGV, $ARGV);</span><br /><span class="line">               while (&lt;ARGV&gt;) {</span><br /><span class="line">                    ...       # code for each line</span><br /><span class="line">               }</span><br /><span class="line">          }</span><br /><span class="line"></span><br /><span class="line">     except that it isn&#39;t as cumbersome to say.  It  really  does</span><br /><span class="line">     shift  array ARGV and put the current filename into variable</span><br /><span class="line">     ARGV.  It also uses filehandle  ARGV  internally.   You  can</span><br /><span class="line">     modify  @ARGV  before  the first &lt;&gt; as long as you leave the</span><br /><span class="line">     first filename at the beginning of the array.  Line  numbers</span><br /><span class="line">     ($.)  continue as if the input was one big happy file.  (But</span><br /><span class="line">     see example under eof for how to reset line numbers on  each</span><br /><span class="line">     file.)</span><br /><span class="line"></span><br /><span class="line">     If you want to set @ARGV to your own list of files, go right</span><br /><span class="line">     ahead.   If  you want to pass switches into your script, you</span><br /><span class="line">     can put a loop on the front like this:</span><br /><span class="line"></span><br /><span class="line">          while ($_ = $ARGV[0], /^-/) {</span><br /><span class="line">               shift;</span><br /><span class="line">              last if /^--$/;</span><br /><span class="line">               /^-D(.*)/ &amp;&amp; ($debug = $1);</span><br /><span class="line">               /^-v/ &amp;&amp; $verbose++;</span><br /><span class="line">               ...       # other switches</span><br /><span class="line">          }</span><br /><span class="line">          while (&lt;&gt;) {</span><br /><span class="line">               ...       # code for each line</span><br /><span class="line">          }</span><br /><span class="line"></span><br /><span class="line">     The &lt;&gt; symbol will return FALSE only once.  If you  call  it</span><br /><span class="line">     again  after  this it will assume you are processing another</span><br /><span class="line">     @ARGV list, and if you haven&#39;t set @ARGV,  will  input  from</span><br /><span class="line">     STDIN.</span><br /><span class="line"></span><br /><span class="line">     If the string inside the angle brackets is a reference to  a</span><br /><span class="line">     scalar  variable  (e.g. &lt;$foo&gt;), then that variable contains</span><br /><span class="line">     the name of the filehandle to input from.</span><br /><span class="line"></span><br /><span class="line">     If the string inside angle brackets is not a filehandle,  it</span><br /><span class="line">     is  interpreted  as  a  filename  pattern to be globbed, and</span><br /><span class="line">     either an array of filenames or the  next  filename  in  the</span><br /><span class="line">     list  is  returned,  depending  on  context.  One level of $</span><br /><span class="line">     interpretation is done  first,  but  you  can&#39;t  say  &lt;$foo&gt;</span><br /><span class="line">     because  that&#39;s  an  indirect filehandle as explained in the</span><br /><span class="line">     previous paragraph.  You  could  insert  curly  brackets  to</span><br /><span class="line">     force interpretation as a filename glob: &lt;${foo}&gt;.  Example:</span><br /><span class="line"></span><br /><span class="line">          while (&lt;*.c&gt;) {</span><br /><span class="line">               chmod 0644, $_;</span><br /><span class="line">          }</span><br /><span class="line"></span><br /><span class="line">     is equivalent to</span><br /><span class="line"></span><br /><span class="line">          open(foo, &#34;echo *.c | tr -s &#39; \t\r\f&#39; &#39;\\012\\012\\012\\012&#39;|&#34;);</span><br /><span class="line">          while (&lt;foo&gt;) {</span><br /><span class="line">               chop;</span><br /><span class="line">               chmod 0644, $_;</span><br /><span class="line">          }</span><br /><span class="line"></span><br /><span class="line">     In fact, it&#39;s currently implemented that way.  (Which  means</span><br /><span class="line">     it will not work on filenames with spaces in them unless you</span><br /><span class="line">     have /bin/csh on your machine.)  Of course, the shortest way</span><br /><span class="line">     to do the above is:</span><br /><span class="line"></span><br /><span class="line">          chmod 0644, &lt;*.c&gt;;</span><br /></pre>
  
  
  


      </article>

    </section>

  </body>

</html>

