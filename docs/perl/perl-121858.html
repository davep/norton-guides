





<!DOCTYPE html>
<html>

  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <meta name="generator" content="ng2web v1.1.0 (ngdb v1.1.0)">
    <link rel="stylesheet" type="text/css" href="perl-style.css">
    <title>PERL 4.0 Reference Guide » PERL » Languages</title>
    <meta name="description" content="PERL 4.0 Reference Guide">
    <link rel="prev" href="perl-118962.html">
    <link rel="next" href="perl-126256.html">
    
  </head>

  <body>

    <header>
      <nav class="box">
        <ul>
          

<li><a href="perl-about.html">About</a></li>


          

<li><a href="perl-118962.html">Previous</a></li>


          

<li><a href="perl-90961.html">Up</a></li>


          

<li><a href="perl-126256.html">Next</a></li>


        </ul>
      </nav>
    </header>

    <section>

      <nav class="menu box">
        <ul>
            <li>PERL</li>
            <ul>
              <li><a href="index.html">Commands</a></li>
              <li><a href="perl-90961.html">Languages</a></li>
              <li><a href="perl-159711.html">Command line options</a></li>
              <li><a href="perl-170094.html">Regular Expressions</a></li>
              <li><a href="perl-171332.html">Special Variables</a></li>
              <li><a href="perl-188582.html">Operators</a></li>
              <li><a href="perl-197905.html">Debugging</a></li>
              
            </ul>
            <li>Tables</li>
            <ul>
              <li><a href="perl-204383.html">ASCII Chart</a></li>
              <li><a href="perl-207014.html">Literals</a></li>
              <li><a href="perl-207867.html">Credits</a></li>
              
            </ul>
        </ul>
      </nav>

      <article class="box">
        
  
  
    <pre class="entry"><span class="line"></span><br /><span class="line">     Precedence</span><br /><span class="line"></span><br /><span class="line">     Perl operators have the  following  associativity  and  pre-</span><br /><span class="line">     cedence:</span><br /><span class="line"></span><br /><span class="line">     nonassoc  print printf exec system sort reverse</span><br /><span class="line">                    chmod chown kill unlink utime die return</span><br /><span class="line">     left      ,</span><br /><span class="line">     right     = += -= *= etc.</span><br /><span class="line">     right     ?:</span><br /><span class="line">     nonassoc  ..</span><br /><span class="line">     left      ||</span><br /><span class="line">     left      &amp;&amp;</span><br /><span class="line">     left      | ^</span><br /><span class="line">     left      &amp;</span><br /><span class="line">     nonassoc  == != &lt;=&gt; eq ne cmp</span><br /><span class="line">     nonassoc  &lt; &gt; &lt;= &gt;= lt gt le ge</span><br /><span class="line">     nonassoc  chdir exit eval reset sleep rand umask</span><br /><span class="line">     nonassoc  -r -w -x etc.</span><br /><span class="line">     left      &lt;&lt; &gt;&gt;</span><br /><span class="line">     left      + - .</span><br /><span class="line">     left      * / % x</span><br /><span class="line">     left      =~ !~</span><br /><span class="line">     right     ! ~ and unary minus</span><br /><span class="line">     right     **</span><br /><span class="line">     nonassoc  ++ --</span><br /><span class="line">     left      &#39;(&#39;</span><br /><span class="line"></span><br /><span class="line">     As mentioned earlier, if any list operator (print, etc.)  or</span><br /><span class="line">     any  unary  operator  (chdir,  etc.)   is followed by a left</span><br /><span class="line">     parenthesis as the next token on the same line, the operator</span><br /><span class="line">     and  arguments within parentheses are taken to be of highest</span><br /><span class="line">     precedence, just like a normal function call.  Examples:</span><br /><span class="line"></span><br /><span class="line">          chdir $foo || die;       # (chdir $foo) || die</span><br /><span class="line">          chdir($foo) || die;      # (chdir $foo) || die</span><br /><span class="line">          chdir ($foo) || die;     # (chdir $foo) || die</span><br /><span class="line">          chdir +($foo) || die;    # (chdir $foo) || die</span><br /><span class="line"></span><br /><span class="line">     but, because * is higher precedence than ||:</span><br /><span class="line"></span><br /><span class="line">          chdir $foo * 20;         # chdir ($foo * 20)</span><br /><span class="line">          chdir($foo) * 20;        # (chdir $foo) * 20</span><br /><span class="line">          chdir ($foo) * 20;       # (chdir $foo) * 20</span><br /><span class="line">          chdir +($foo) * 20;      # chdir ($foo * 20)</span><br /><span class="line"></span><br /><span class="line">          rand 10 * 20;            # rand (10 * 20)</span><br /><span class="line">          rand(10) * 20;           # (rand 10) * 20</span><br /><span class="line">          rand (10) * 20;          # (rand 10) * 20</span><br /><span class="line">          rand +(10) * 20;         # rand (10 * 20)</span><br /><span class="line"></span><br /><span class="line">     In the absence of parentheses, the precedence of list opera-</span><br /><span class="line">     tors  such  as  print,  sort or chmod is either very high or</span><br /><span class="line">     very low depending on whether you look at the left  side  of</span><br /><span class="line">     operator or the right side of it.  For example, in</span><br /><span class="line"></span><br /><span class="line">          @ary = (1, 3, sort 4, 2);</span><br /><span class="line">          print @ary;         # prints 1324</span><br /><span class="line"></span><br /><span class="line">     the commas on the right of the sort are evaluated before the</span><br /><span class="line">     sort,  but  the  commas on the left are evaluated after.  In</span><br /><span class="line">     other words, list operators tend to gobble up all the  argu-</span><br /><span class="line">     ments that follow them, and then act like a simple term with</span><br /><span class="line">     regard to the preceding expression.  Note that you  have  to</span><br /><span class="line">     be careful with parens:</span><br /><span class="line"></span><br /><span class="line">          # These evaluate exit before doing the print:</span><br /><span class="line">          print($foo, exit);  # Obviously not what you want.</span><br /><span class="line">          print $foo, exit;   # Nor is this.</span><br /><span class="line"></span><br /><span class="line">          # These do the print before evaluating exit:</span><br /><span class="line">          (print $foo), exit; # This is what you want.</span><br /><span class="line">          print($foo), exit;  # Or this.</span><br /><span class="line">          print ($foo), exit; # Or even this.</span><br /><span class="line"></span><br /><span class="line">     Also note that</span><br /><span class="line"></span><br /><span class="line">          print ($foo &amp; 255) + 1, &#34;\n&#34;;</span><br /><span class="line"></span><br /><span class="line">     probably doesn&#39;t do what you expect at first glance.</span><br /><span class="line"></span><br /><span class="line">     Subroutines</span><br /><span class="line"></span><br /><span class="line">     A subroutine may be declared as follows:</span><br /><span class="line"></span><br /><span class="line">         sub NAME BLOCK</span><br /><span class="line"></span><br /><span class="line">     Any arguments passed to the routine come  in  as  array  @_,</span><br /><span class="line">     that is ($_[0], $_[1], ...).  The array @_ is a local array,</span><br /><span class="line">     but its values are references to the actual  scalar  parame-</span><br /><span class="line">     ters.   The  return  value of the subroutine is the value of</span><br /><span class="line">     the last expression evaluated, and can be  either  an  array</span><br /><span class="line">     value  or  a  scalar value.  Alternately, a return statement</span><br /><span class="line">     may be used to specify the returned value and exit the  sub-</span><br /><span class="line">     routine.  To create local variables see the local operator.</span><br /><span class="line"></span><br /><span class="line">     A subroutine is called using the do operator or the &amp; opera-</span><br /><span class="line">     tor.</span><br /><span class="line"></span><br /><span class="line">     Example:</span><br /><span class="line"></span><br /><span class="line">          sub MAX {</span><br /><span class="line">               local($max) = pop(@_);</span><br /><span class="line">               foreach $foo (@_) {</span><br /><span class="line">                    $max = $foo if $max &lt; $foo;</span><br /><span class="line">               }</span><br /><span class="line">               $max;</span><br /><span class="line">          }</span><br /><span class="line"></span><br /><span class="line">          ...</span><br /><span class="line">          $bestday = &amp;MAX($mon,$tue,$wed,$thu,$fri);</span><br /><span class="line"></span><br /><span class="line">     Example:</span><br /><span class="line"></span><br /><span class="line">          # get a line, combining continuation lines</span><br /><span class="line">          #  that start with whitespace</span><br /><span class="line">          sub get_line {</span><br /><span class="line">               $thisline = $lookahead;</span><br /><span class="line">               line: while ($lookahead = &lt;STDIN&gt;) {</span><br /><span class="line">                    if ($lookahead =~ /^[ \t]/) {</span><br /><span class="line">                         $thisline .= $lookahead;</span><br /><span class="line">                    }</span><br /><span class="line">                    else {</span><br /><span class="line">                         last line;</span><br /><span class="line">                    }</span><br /><span class="line">               }</span><br /><span class="line">               $thisline;</span><br /><span class="line">          }</span><br /><span class="line"></span><br /><span class="line">          $lookahead = &lt;STDIN&gt;;    # get first line</span><br /><span class="line">          while ($_ = do get_line()) {</span><br /><span class="line">               ...</span><br /><span class="line">          }</span><br /><span class="line"></span><br /><span class="line">     Use array assignment to a local list to name your formal arguments:</span><br /><span class="line"></span><br /><span class="line">          sub maybeset {</span><br /><span class="line">               local($key, $value) = @_;</span><br /><span class="line">               $foo{$key} = $value unless $foo{$key};</span><br /><span class="line">          }</span><br /><span class="line"></span><br /><span class="line">     This also has the effect of turning  call-by-reference  into</span><br /><span class="line">     call-by-value, since the assignment copies the values.</span><br /><span class="line"></span><br /><span class="line">     Subroutines may be called recursively.  If a  subroutine  is</span><br /><span class="line">     called  using the &amp; form, the argument list is optional.  If</span><br /><span class="line">     omitted, no @_ array is set up for the  subroutine;  the  @_</span><br /><span class="line">     array  at  the  time  of  the  call is visible to subroutine</span><br /><span class="line">     instead.</span><br /><span class="line"></span><br /><span class="line">          do foo(1,2,3);      # pass three arguments</span><br /><span class="line">          &amp;foo(1,2,3);        # the same</span><br /><span class="line"></span><br /><span class="line">          do foo();      # pass a null list</span><br /><span class="line">          &amp;foo();             # the same</span><br /><span class="line">          &amp;foo;               # pass no arguments--more efficient</span><br /></pre>
  
  
  


      </article>

    </section>

  </body>

</html>

