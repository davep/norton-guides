





<!DOCTYPE html>
<html>

  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <meta name="generator" content="ng2web v1.2.0 (ngdb v1.1.0)">
    <link rel="stylesheet" type="text/css" href="perl-style.css">
    <title>PERL 4.0 Reference Guide » PERL » Languages</title>
    <meta name="description" content="PERL 4.0 Reference Guide">
    <link rel="prev" href="perl-111227.html">
    <link rel="next" href="perl-117908.html">
    
  </head>

  <body>

    <header>
      <nav class="box">
        <ul>
          

<li><a href="../index.html">Guides</a></li>


          

<li><a href="perl-about.html">About</a></li>


          

<li><a href="perl-111227.html">Previous</a></li>


          

<li><a href="perl-90961.html">Up</a></li>


          

<li><a href="perl-117908.html">Next</a></li>


        </ul>
      </nav>
    </header>

    <section>

      
        <nav class="menu box">
          <ul>
              <li>PERL</li>
              <ul>
                <li><a href="index.html">Commands</a></li>
                <li><a href="perl-90961.html">Languages</a></li>
                <li><a href="perl-159711.html">Command line options</a></li>
                <li><a href="perl-170094.html">Regular Expressions</a></li>
                <li><a href="perl-171332.html">Special Variables</a></li>
                <li><a href="perl-188582.html">Operators</a></li>
                <li><a href="perl-197905.html">Debugging</a></li>
                
              </ul>
              <li>Tables</li>
              <ul>
                <li><a href="perl-204383.html">ASCII Chart</a></li>
                <li><a href="perl-207014.html">Literals</a></li>
                <li><a href="perl-207867.html">Credits</a></li>
                
              </ul>
          </ul>
        </nav>
      

      <article class="box">
        
  
  
    <pre class="entry"><span class="line"></span><br /><span class="line">     Compound statements</span><br /><span class="line"></span><br /><span class="line">     In perl, a sequence of commands may be treated as  one  com-</span><br /><span class="line">     mand by enclosing it in curly brackets.  We will call this a</span><br /><span class="line">     BLOCK.</span><br /><span class="line"></span><br /><span class="line">     The following compound commands may be used to control flow:</span><br /><span class="line"></span><br /><span class="line">          if (EXPR) BLOCK</span><br /><span class="line">          if (EXPR) BLOCK else BLOCK</span><br /><span class="line">          if (EXPR) BLOCK elsif (EXPR) BLOCK ... else BLOCK</span><br /><span class="line">          LABEL while (EXPR) BLOCK</span><br /><span class="line">          LABEL while (EXPR) BLOCK continue BLOCK</span><br /><span class="line">          LABEL for (EXPR; EXPR; EXPR) BLOCK</span><br /><span class="line">          LABEL foreach VAR (ARRAY) BLOCK</span><br /><span class="line">          LABEL BLOCK continue BLOCK</span><br /><span class="line"></span><br /><span class="line">     Note that, unlike C and Pascal, these are defined  in  terms</span><br /><span class="line">     of BLOCKs, not statements.  This means that the curly brack-</span><br /><span class="line">     ets are required--no dangling statements  allowed.   If  you</span><br /><span class="line">     want  to write conditionals without curly brackets there are</span><br /><span class="line">     several other ways to do it.  The following all do the  same</span><br /><span class="line">     thing:</span><br /><span class="line"></span><br /><span class="line">          if (!open(foo)) { die &#34;Can&#39;t open $foo: $!&#34;; }</span><br /><span class="line">          die &#34;Can&#39;t open $foo: $!&#34; unless open(foo);</span><br /><span class="line">          open(foo) || die &#34;Can&#39;t open $foo: $!&#34;; # foo or bust!</span><br /><span class="line">          open(foo) ? &#39;hi mom&#39; : die &#34;Can&#39;t open $foo: $!&#34;;</span><br /><span class="line">                         # a bit exotic, that last one</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">     The if  statement  is  straightforward.   Since  BLOCKs  are</span><br /><span class="line">     always  bounded  by curly brackets, there is never any ambi-</span><br /><span class="line">     guity about which if an else goes with.  If you  use  unless</span><br /><span class="line">     in place of if, the sense of the test is reversed.</span><br /><span class="line"></span><br /><span class="line">     The while statement  executes  the  block  as  long  as  the</span><br /><span class="line">     expression  is true (does not evaluate to the null string or</span><br /><span class="line">     0).  The LABEL is optional, and if present, consists  of  an</span><br /><span class="line">     identifier  followed  by  a colon.  The LABEL identifies the</span><br /><span class="line">     loop for the loop control statements next,  last,  and  redo</span><br /><span class="line">     (see  below).   If  there  is a continue BLOCK, it is always</span><br /><span class="line">     executed  just  before  the  conditional  is  about  to   be</span><br /><span class="line">     evaluated  again,  similarly to the third part of a for loop</span><br /><span class="line">     in C.  Thus it can be used to  increment  a  loop  variable,</span><br /><span class="line">     even when the loop has been continued via the next statement</span><br /><span class="line">     (similar to the C &#34;continue&#34; statement).</span><br /><span class="line"></span><br /><span class="line">     If the word while is replaced by the word until,  the  sense</span><br /><span class="line">     of the test is reversed, but the conditional is still tested</span><br /><span class="line">     before the first iteration.</span><br /><span class="line"></span><br /><span class="line">     In either the if or the while  statement,  you  may  replace</span><br /><span class="line">     &#34;(EXPR)&#34;  with  a  BLOCK, and the conditional is true if the</span><br /><span class="line">     value of the last command in that block is true.</span><br /><span class="line"></span><br /><span class="line">     The for loop works  exactly  like  the  corresponding  while</span><br /><span class="line">     loop:</span><br /><span class="line"></span><br /><span class="line">          for ($i = 1; $i &lt; 10; $i++) {</span><br /><span class="line">               ...</span><br /><span class="line">          }</span><br /><span class="line"></span><br /><span class="line">     is the same as</span><br /><span class="line"></span><br /><span class="line">          $i = 1;</span><br /><span class="line">          while ($i &lt; 10) {</span><br /><span class="line">               ...</span><br /><span class="line">          } continue {</span><br /><span class="line">               $i++;</span><br /><span class="line">          }</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">     The foreach loop iterates over a normal array value and sets</span><br /><span class="line">     the  variable  VAR  to be each element of the array in turn.</span><br /><span class="line">     The variable is implicitly local to the  loop,  and  regains</span><br /><span class="line">     its  former value upon exiting the loop.  The &#34;foreach&#34; key-</span><br /><span class="line">     word is actually identical to the &#34;for&#34; keyword, so you  can</span><br /><span class="line">     use  &#34;foreach&#34; for readability or &#34;for&#34; for brevity.  If VAR</span><br /><span class="line">     is omitted, $_ is set to each value.  If ARRAY is an  actual</span><br /><span class="line">     array  (as  opposed  to  an  expression  returning  an array</span><br /><span class="line">     value), you can modify each element of the array by  modify-</span><br /><span class="line">     ing VAR inside the loop.  Examples:</span><br /><span class="line"></span><br /><span class="line">          for (@ary) { s/foo/bar/; }</span><br /><span class="line"></span><br /><span class="line">          foreach $elem (@elements) {</span><br /><span class="line">               $elem *= 2;</span><br /><span class="line">          }</span><br /><span class="line"></span><br /><span class="line">          for ((10,9,8,7,6,5,4,3,2,1,&#39;BOOM&#39;)) {</span><br /><span class="line">               print $_, &#34;\n&#34;; sleep(1);</span><br /><span class="line">          }</span><br /><span class="line"></span><br /><span class="line">          for (1..15) { print &#34;Merry Christmas\n&#34;; }</span><br /><span class="line"></span><br /><span class="line">          foreach $item (split(/:[\\\n:]*/, $ENV{&#39;TERMCAP&#39;})) {</span><br /><span class="line">               print &#34;Item: $item\n&#34;;</span><br /><span class="line">          }</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">     The BLOCK by itself (labeled or not) is equivalent to a loop</span><br /><span class="line">     that  executes  once.  Thus you can use any of the loop con-</span><br /><span class="line">     trol statements in it to leave or restart  the  block.   The</span><br /><span class="line">     continue  block is optional.  This construct is particularly</span><br /><span class="line">     nice for doing case structures.</span><br /><span class="line"></span><br /><span class="line">          foo: {</span><br /><span class="line">               if (/^abc/) { $abc = 1; last foo; }</span><br /><span class="line">               if (/^def/) { $def = 1; last foo; }</span><br /><span class="line">               if (/^xyz/) { $xyz = 1; last foo; }</span><br /><span class="line">               $nothing = 1;</span><br /><span class="line">          }</span><br /><span class="line"></span><br /><span class="line">     There is no official switch statement in perl, because there</span><br /><span class="line">     are  already several ways to write the equivalent.  In addi-</span><br /><span class="line">     tion to the above, you could write</span><br /><span class="line"></span><br /><span class="line">          foo: {</span><br /><span class="line">               $abc = 1, last foo  if /^abc/;</span><br /><span class="line">               $def = 1, last foo  if /^def/;</span><br /><span class="line">               $xyz = 1, last foo  if /^xyz/;</span><br /><span class="line">               $nothing = 1;</span><br /><span class="line">          }</span><br /><span class="line"></span><br /><span class="line">     or</span><br /><span class="line"></span><br /><span class="line">          foo: {</span><br /><span class="line">               /^abc/ &amp;&amp; do { $abc = 1; last foo; };</span><br /><span class="line">               /^def/ &amp;&amp; do { $def = 1; last foo; };</span><br /><span class="line">               /^xyz/ &amp;&amp; do { $xyz = 1; last foo; };</span><br /><span class="line">               $nothing = 1;</span><br /><span class="line">          }</span><br /><span class="line"></span><br /><span class="line">     or</span><br /><span class="line"></span><br /><span class="line">          foo: {</span><br /><span class="line">               /^abc/ &amp;&amp; ($abc = 1, last foo);</span><br /><span class="line">               /^def/ &amp;&amp; ($def = 1, last foo);</span><br /><span class="line">               /^xyz/ &amp;&amp; ($xyz = 1, last foo);</span><br /><span class="line">               $nothing = 1;</span><br /><span class="line">          }</span><br /><span class="line"></span><br /><span class="line">     or even</span><br /><span class="line"></span><br /><span class="line">          if (/^abc/)</span><br /><span class="line">               { $abc = 1; }</span><br /><span class="line">          elsif (/^def/)</span><br /><span class="line">               { $def = 1; }</span><br /><span class="line">          elsif (/^xyz/)</span><br /><span class="line">               { $xyz = 1; }</span><br /><span class="line">          else</span><br /><span class="line">               {$nothing = 1;}</span><br /><span class="line"></span><br /><span class="line">     As it happens, these  are  all  optimized  internally  to  a</span><br /><span class="line">     switch  structure,  so  perl  jumps  directly to the desired</span><br /><span class="line">     statement, and you needn&#39;t worry about perl executing a  lot</span><br /><span class="line">     of  unnecessary  statements  when  you  have  a string of 50</span><br /><span class="line">     elsifs, as long as you are testing the  same  simple  scalar</span><br /><span class="line">     variable  using  ==,  eq, or pattern matching as above.  (If</span><br /><span class="line">     you&#39;re curious as to whether the optimizer has done this for</span><br /><span class="line">     a  particular  case statement, you can use the -D1024 switch</span><br /><span class="line">     to list the syntax tree before execution.)</span><br /></pre>
  
  
  


      </article>

    </section>

    
      <footer>
        <nav class="box">
          <dl>
            <dt>Generated</dt><dd>2025-12-02 09:10:30</dd>
            <dt>Generator</dt><dd><a href="https://ng2web.davep.dev">ng2web v1.2.0 (ngdb v1.1.0)</a></dd>
          </dl>
        </nav>
      </footer>
    

  </body>

</html>

