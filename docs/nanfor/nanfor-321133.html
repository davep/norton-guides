





<!DOCTYPE html>
<html>

  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <meta name="generator" content="ng2web v1.1.0 (ngdb v1.1.0)">
    <link rel="stylesheet" type="text/css" href="nanfor-style.css">
    <title>Nanforum Toolkit v3.05 Reference Guide » Information » Using CPMI</title>
    <meta name="description" content="Nanforum Toolkit v3.05 Reference Guide">
    
    <link rel="next" href="nanfor-328331.html">
    
  </head>

  <body>

    <header>
      <nav class="box">
        <ul>
          

<li><a href="../index.html">Guides</a></li>


          

<li><a href="nanfor-about.html">About</a></li>


          

<li><span>Previous</span></li>


          

<li><a href="nanfor-321056.html">Up</a></li>


          

<li><a href="nanfor-328331.html">Next</a></li>


        </ul>
      </nav>
    </header>

    <section>

      <nav class="menu box">
        <ul>
            <li>A-F</li>
            <ul>
              <li><a href="index.html">Array</a></li>
              <li><a href="nanfor-16449.html">Conversion</a></li>
              <li><a href="nanfor-30306.html">DOS/BIOS</a></li>
              <li><a href="nanfor-59070.html">Date/Time</a></li>
              <li><a href="nanfor-102173.html">Environment</a></li>
              <li><a href="nanfor-109763.html">Event</a></li>
              <li><a href="nanfor-113206.html">File I/O</a></li>
              
            </ul>
            <li>G-Z</li>
            <ul>
              <li><a href="nanfor-137249.html">Game</a></li>
              <li><a href="nanfor-137802.html">Keyboard/Mouse</a></li>
              <li><a href="nanfor-181545.html">Math</a></li>
              <li><a href="nanfor-186992.html">Menus/Prompts</a></li>
              <li><a href="nanfor-223163.html">NetWare</a></li>
              <li><a href="nanfor-237863.html">String</a></li>
              <li><a href="nanfor-260934.html">Video</a></li>
              
            </ul>
            <li>Information</li>
            <ul>
              <li><a href="nanfor-285956.html">Overview</a></li>
              <li><a href="nanfor-314363.html">Sample source code headers</a></li>
              <li><a href="nanfor-321056.html">Using CPMI</a></li>
              
            </ul>
        </ul>
      </nav>

      <article class="box">
        
  
  
    <pre class="entry"><span class="line"></span><br /><span class="line">   CPMI Overview</span><br /><span class="line">   =======================================================================</span><br /><span class="line"></span><br /><span class="line">   The CA-Clipper community has been blessed in recent months with the</span><br /><span class="line">   ability to create Clipper applications that run in protected mode.</span><br /><span class="line">   There are currently three different products (and who knows, maybe more</span><br /><span class="line">   to come) that alleviate many memory problems associated with Clipper</span><br /><span class="line">   programming and have brought relief to long-suffering developers.</span><br /><span class="line"></span><br /><span class="line">   As with all silver linings, however, this one has a dark cloud &lt;g&gt;.</span><br /><span class="line">   Many third-party libraries, as well as some home-grown C / ASM code,</span><br /><span class="line">   will not work with these products because they break protected mode</span><br /><span class="line">   programming rules (no one&#39;s fault, really -- the DOS extender products</span><br /><span class="line">   are very new and prior to their release no one expected Clipper apps to</span><br /><span class="line">   ever run in anything but real mode).  To their credit, the vendors of</span><br /><span class="line">   the DOS extender products have attempted to minimize the problem by</span><br /><span class="line">   providing APIs that can be used to make C or assembler code compatible</span><br /><span class="line">   with protected mode.  Unfortunately, each vendor uses its own set of</span><br /><span class="line">   API functions, so a function written for one API will not work when</span><br /><span class="line">   used with a different DOS extender.</span><br /><span class="line"></span><br /><span class="line">   The Clipper Protected Mode Interface (hereafter called CPMI) is an</span><br /><span class="line">   attempt to solve this problem.  It provides a set of generic functions</span><br /><span class="line">   that will work regardless of which DOS extender is used.  This is made</span><br /><span class="line">   possible by the fact that all the existing extender products support</span><br /><span class="line">   the use of the DOS Protected Mode Interface (DPMI) specification, even</span><br /><span class="line">   when the application is not running under a DPMI host.  The functions</span><br /><span class="line">   in the CPMI API use DPMI calls to achieve compatibility with any DOS</span><br /><span class="line">   extender that supports the DPMI protocol.</span><br /><span class="line"></span><br /><span class="line">   Another attractive feature is that the CPMI is Public Domain, so it may</span><br /><span class="line">   be freely distributed by third-party developers and anyone else who</span><br /><span class="line">   needs its services.  It is hoped that this will simplify compliance</span><br /><span class="line">   with protected mode rules since it is no longer necessary to support</span><br /><span class="line">   each vendor&#39;s API.</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">   Programming in protected mode</span><br /><span class="line">   ========================================================================</span><br /><span class="line"></span><br /><span class="line">   Although coding for protected mode is a new experience for most of us,</span><br /><span class="line">   it is not difficult and any code will run fine as long as a few simple</span><br /><span class="line">   rules are followed.  Failure to follow the rules will result in a</span><br /><span class="line">   General Protection Fault (GPF), which is actually nice in a way because</span><br /><span class="line">   it makes finding memory-related bugs much easier.  Adhere to the</span><br /><span class="line">   following rules and you should be able to avoid GPFs:</span><br /><span class="line"></span><br /><span class="line">   1.  A selector value (referred to as a segment value in real mode)</span><br /><span class="line">       loaded into a segment register actually maps to a chunk of memory</span><br /><span class="line">       that may be located anywhere within the physical address space.</span><br /><span class="line">       With extenders that support virtual memory, the selector can even</span><br /><span class="line">       refer to memory that has been swapped to disk.</span><br /><span class="line"></span><br /><span class="line">       a)  Never load a segment register with junk values or a GPF will</span><br /><span class="line">           probably occur.  Every time a segment register is loaded with a</span><br /><span class="line">           value the microprocessor checks to make sure it is a valid</span><br /><span class="line">           selector and generates a GP fault if it is not.</span><br /><span class="line"></span><br /><span class="line">       b)  Never perform segment arithmetic on a selector value.  This is</span><br /><span class="line">           done in real mode code to either normalize a pointer, force</span><br /><span class="line">           segments to be aligned on a specific boundary, or to access</span><br /><span class="line">           data that is greater than 64K in size.  A selector value is a</span><br /><span class="line">           unique ID which has no relationship to a specific physical</span><br /><span class="line">           memory location.</span><br /><span class="line"></span><br /><span class="line">       c)  All selectors have a size associated with them and attempts to</span><br /><span class="line">           access data at an offset greater than that size will result in</span><br /><span class="line">           a GPF.  This is one of the greatest strengths of a DOS Extender</span><br /><span class="line">           because most obscure bugs in real mode code occur when a wild</span><br /><span class="line">           pointer is used.  This will usually cause a GPF in protected</span><br /><span class="line">           mode because either the selector or offset value will be</span><br /><span class="line">           invalid.</span><br /><span class="line"></span><br /><span class="line">       d)  Segment registers can be loaded with a selector value of 0 (a</span><br /><span class="line">           NULL selector), but never try to write to or read from a NULL</span><br /><span class="line">           selector.</span><br /><span class="line"></span><br /><span class="line">       e)  Segment values in real mode always point to a physical address</span><br /><span class="line">           equal to the segment value multiplied by 16, but selector</span><br /><span class="line">           values in protected mode may point to anywhere in memory.  The</span><br /><span class="line">           CPMI contains services for obtaining protected mode selectors</span><br /><span class="line">           from real mode addresses.</span><br /><span class="line"></span><br /><span class="line">   2)  You cannot execute code in a data segment and you cannot write to</span><br /><span class="line">       data in the code segment.</span><br /><span class="line"></span><br /><span class="line">   3)  You may not directly issue real mode interrupts from protected</span><br /><span class="line">       mode.  The CPMI has services for calling real mode interrupts if</span><br /><span class="line">       you find it necessary.</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">   The CPMI.H header file</span><br /><span class="line">   ========================================================================</span><br /><span class="line"></span><br /><span class="line">   Prototypes for all of the CPMI functions can be found in the CPMI.H</span><br /><span class="line">   header file, along with a few typedefs used by by the CPMI.  In</span><br /><span class="line">   addition, each .ASM source file contains a detailed function header</span><br /><span class="line">   that describes syntax and return value information.</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">   Writing Toolkit functions for protected mode</span><br /><span class="line">   ========================================================================</span><br /><span class="line"></span><br /><span class="line">   Most Toolkit functions will work fine in protected mode with no</span><br /><span class="line">   modifications.  In some cases, however, the function may need to be</span><br /><span class="line">   altered to achieve protected mode compatibility.  To prevent a</span><br /><span class="line">   version-control nightmare, all Toolkit functions should be written such</span><br /><span class="line">   that the SAME CODE will work in both real and protected mode -- i.e.</span><br /><span class="line">   there SHOULD NOT be two separate versions of the same function.</span><br /><span class="line"></span><br /><span class="line">   This is much easier than it might appear at first glance.  For example,</span><br /><span class="line">   consider the following function from version 2.0 of the Toolkit:</span><br /><span class="line"></span><br /><span class="line">        CLIPPER FT_Alt( void )</span><br /><span class="line">        {</span><br /><span class="line">           _retl( ( int ) ( ( * ( char * ) 0x00000417 ) &amp; 0x8 ) );</span><br /><span class="line"></span><br /><span class="line">           return;</span><br /><span class="line">        }</span><br /><span class="line"></span><br /><span class="line">   This function returns the state of the ALT key, and it works just fine</span><br /><span class="line">   in real mode.  In protected mode, however, it causes a GPF because a</span><br /><span class="line">   null selector is involved.  It can easily be fixed, though, by using</span><br /><span class="line">   the address 0040:0017 instead of 0000:0417.  The two addresses point to</span><br /><span class="line">   the exact same physical memory in real mode, and in protected mode the</span><br /><span class="line">   DOS extender provides a selector of 40h that corresponds to the real</span><br /><span class="line">   mode segment 40h.</span><br /><span class="line"></span><br /><span class="line">   It won&#39;t always be so simple, of course.  In some cases it may be</span><br /><span class="line">   necessary to construct the code such that it works slightly differently</span><br /><span class="line">   depending on the CPU mode.  For example, suppose you wanted to retrieve</span><br /><span class="line">   the BIOS date stamp at F000:FFF5.  Making it compatible with both real</span><br /><span class="line">   and protected mode isn&#39;t hard when you use the CPMI services:</span><br /><span class="line"></span><br /><span class="line">        #define DATEPTR ( ( char * ) 0xF000FFF5 ) )</span><br /><span class="line"></span><br /><span class="line">        CLIPPER BIOSDate( void )</span><br /><span class="line">        {</span><br /><span class="line">           auto int isProtMode = cpmiIsProtected();</span><br /><span class="line">           auto char * cDate;</span><br /><span class="line"></span><br /><span class="line">           if ( isProtMode )</span><br /><span class="line">           {</span><br /><span class="line">              FP_SEG( cDate ) = cpmiProtectedPtr( DATEPTR, 8 );</span><br /><span class="line">              FP_OFF( cDate ) = 0;</span><br /><span class="line">           }</span><br /><span class="line">           else</span><br /><span class="line">              cDate = DATEPTR;</span><br /><span class="line"></span><br /><span class="line">           _retclen( cDate, 8 );</span><br /><span class="line"></span><br /><span class="line">           if ( isProtMode ) cpmiFreeSelector( FP_SEG( cDate ) );</span><br /><span class="line"></span><br /><span class="line">           return;</span><br /><span class="line">        }</span><br /><span class="line"></span><br /><span class="line">   Given the ease with which it can be done, all Toolkit functions are</span><br /><span class="line">   required to work in either real or protected mode.  The CPMI API exists</span><br /><span class="line">   to help you accomplish this goal.  If you require further assistance,</span><br /><span class="line">   please contact the Toolkit librarian or the CPMI author.</span><br /></pre>
  
  
  


      </article>

    </section>

  </body>

</html>

