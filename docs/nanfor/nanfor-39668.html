





<!DOCTYPE html>
<html>

  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <meta name="generator" content="ng2web v1.1.0 (ngdb v1.1.0)">
    <link rel="stylesheet" type="text/css" href="nanfor-style.css">
    <title>Nanforum Toolkit v3.05 Reference Guide » A-F » DOS/BIOS</title>
    <meta name="description" content="Nanforum Toolkit v3.05 Reference Guide">
    <link rel="prev" href="nanfor-38772.html">
    <link rel="next" href="nanfor-45727.html">
    
  </head>

  <body>

    <header>
      <nav class="box">
        <ul>
          

<li><a href="../index.html">Guides</a></li>


          

<li><a href="nanfor-about.html">About</a></li>


          

<li><a href="nanfor-38772.html">Previous</a></li>


          

<li><a href="nanfor-30306.html">Up</a></li>


          

<li><a href="nanfor-45727.html">Next</a></li>


        </ul>
      </nav>
    </header>

    <section>

      <nav class="menu box">
        <ul>
            <li>A-F</li>
            <ul>
              <li><a href="index.html">Array</a></li>
              <li><a href="nanfor-16449.html">Conversion</a></li>
              <li><a href="nanfor-30306.html">DOS/BIOS</a></li>
              <li><a href="nanfor-59070.html">Date/Time</a></li>
              <li><a href="nanfor-102173.html">Environment</a></li>
              <li><a href="nanfor-109763.html">Event</a></li>
              <li><a href="nanfor-113206.html">File I/O</a></li>
              
            </ul>
            <li>G-Z</li>
            <ul>
              <li><a href="nanfor-137249.html">Game</a></li>
              <li><a href="nanfor-137802.html">Keyboard/Mouse</a></li>
              <li><a href="nanfor-181545.html">Math</a></li>
              <li><a href="nanfor-186992.html">Menus/Prompts</a></li>
              <li><a href="nanfor-223163.html">NetWare</a></li>
              <li><a href="nanfor-237863.html">String</a></li>
              <li><a href="nanfor-260934.html">Video</a></li>
              
            </ul>
            <li>Information</li>
            <ul>
              <li><a href="nanfor-285956.html">Overview</a></li>
              <li><a href="nanfor-314363.html">Sample source code headers</a></li>
              <li><a href="nanfor-321056.html">Using CPMI</a></li>
              
            </ul>
        </ul>
      </nav>

      <article class="box">
        
  
  
    <pre class="entry"><span class="line"> <span class="ngb">FT_INT86()</span></span><br /><span class="line"> Execute a software interrupt</span><br /><span class="line">──────────────────────────────────────────────────────────────────────────────</span><br /><span class="line"></span><br /><span class="line"> <span class="ngb">Syntax</span></span><br /><span class="line"></span><br /><span class="line">      <span class="fg15 bg1"> FT_INT86( &lt;nInterruptNumber&gt;, &lt;aRegisterValues&gt; ) -&gt; lResult</span></span><br /><span class="line"></span><br /><span class="line"> <span class="ngb">Arguments</span></span><br /><span class="line"></span><br /><span class="line">      <span class="ngb">&lt;nInterruptNumber&gt;</span> is the interrupt to execute.</span><br /><span class="line"></span><br /><span class="line">      <span class="ngb">&lt;aRegisterValues&gt;</span> is an array that contains values to be loaded</span><br /><span class="line">      into the various CPU registers.  The correspondence between</span><br /><span class="line">      registers and array elements is as follows:</span><br /><span class="line"></span><br /><span class="line">               aElement[1]  ==  AX register</span><br /><span class="line">               aElement[2]  ==  BX register</span><br /><span class="line">               aElement[3]  ==  CX register</span><br /><span class="line">               aElement[4]  ==  DX register</span><br /><span class="line">               aElement[5]  ==  SI register</span><br /><span class="line">               aElement[6]  ==  DI register</span><br /><span class="line">               aElement[7]  ==  BP register</span><br /><span class="line">               aElement[8]  ==  DS register</span><br /><span class="line">               aElement[9]  ==  ES register</span><br /><span class="line">               aElement[10] ==  Flags register</span><br /><span class="line"></span><br /><span class="line"> <span class="ngb">Returns</span></span><br /><span class="line"></span><br /><span class="line">      .T. if all parameters valid and the function was able</span><br /><span class="line">          to execute the desired interrupt.</span><br /><span class="line">      .F. if invalid parameters passed.  If you call this function in</span><br /><span class="line">          protected mode, .F. may also be returned if an allocation</span><br /><span class="line">          of low DOS memory fails.</span><br /><span class="line"></span><br /><span class="line">     In addition, the array elements will contain whatever values were in</span><br /><span class="line">     the CPU registers immediately after the interrupt was executed.  If</span><br /><span class="line">     either of the string parameters were altered by the interrupt, these</span><br /><span class="line">     changes will be reflected as well.</span><br /><span class="line"></span><br /><span class="line"> <span class="ngb">Description</span></span><br /><span class="line"></span><br /><span class="line">     It is occasionally useful to be able to call interrupts directly from</span><br /><span class="line">     Clipper, without having to write a separate routine in C or ASM.  This</span><br /><span class="line">     function allows you that capability.</span><br /><span class="line"></span><br /><span class="line">     Given Clipper&#39;s high-level orientation, this function is necessarily</span><br /><span class="line">     somewhat messy to use.  First, declare an array of ten elements to</span><br /><span class="line">     hold the eight values for the CPU registers and two string parameters.</span><br /><span class="line">     Then initialize the array elements with the values that you want the</span><br /><span class="line">     CPU registers to contain when the interrupt is executed.  You need not</span><br /><span class="line">     initialize all the elements.  For example, if the interrupt requires</span><br /><span class="line">     you to specify values for AX, DX, and DS, you would only need to</span><br /><span class="line">     initialize elements 1, 4, and 8.</span><br /><span class="line"></span><br /><span class="line">     Once you have done the required register setup, call FT_INT86(),</span><br /><span class="line">     passing the interrupt number and the register array as parameters.</span><br /><span class="line">     The function will load the CPU with your specified values, execute the</span><br /><span class="line">     interrupt, and then store the contents of the CPU registers back into</span><br /><span class="line">     your array.  This will allow you to evaluate the results of the</span><br /><span class="line">     interrupt.</span><br /><span class="line"></span><br /><span class="line">     Some interrupt services require you to pass the address of a string in</span><br /><span class="line">     a pair of registers.  This function is capable of handling these sorts</span><br /><span class="line">     of situations, but it will take a little work on your part.  If you need</span><br /><span class="line">     to pass a string that uses the DS register, store the string in element</span><br /><span class="line">     8;  if you need to pass a string that uses the ES register, store the</span><br /><span class="line">     string in element 9.  FT_INT86() will detect that you&#39;ve supplied a</span><br /><span class="line">     string instead of a numeric value and will behave accordingly.</span><br /><span class="line"></span><br /><span class="line">     That takes care of obtaining the segment portion of the pointer.  To</span><br /><span class="line">     specify which register is to contain the offset, use the values REG_DS</span><br /><span class="line">     and REG_ES which are defined in the FTINT86.CH file.  When one of these</span><br /><span class="line">     values is found in an array element, it alerts FT_Int86() to use the</span><br /><span class="line">     offset portion of a pointer instead of a numeric value.  REG_DS tells</span><br /><span class="line">     FT_Int86() to use the offset of the string in element 8, while REG_ES</span><br /><span class="line">     tells FT_Int86() to use the offset of the string in element 9.</span><br /><span class="line"></span><br /><span class="line">     All the CPU registers are sixteen bits in size.  Some, however, are</span><br /><span class="line">     also split into two 8-bit registers.  This function is only capable of</span><br /><span class="line">     receiving and returning registers that are 16 bits in size.  To split</span><br /><span class="line">     a 16-bit register into two 8-bit values, you can use the</span><br /><span class="line">     pseudo-functions HighByte() and LowByte(), contained in the .CH file.</span><br /><span class="line"></span><br /><span class="line">     To alter an 8-bit number so it will appear in the high-order byte of a</span><br /><span class="line">     register when passed to the FT_INT86() function, use the MakeHI()</span><br /><span class="line">     pseudo-function contained in the .CH file.</span><br /><span class="line"></span><br /><span class="line">     When run in real mode, this function is a shell for __ftint86(),</span><br /><span class="line">     which is written in assembler and does the actual work of executing</span><br /><span class="line">     the interrupt.  __ftint86() is callable from C, so feel free to</span><br /><span class="line">     incorporate it into any C routines for which it might be useful.  The</span><br /><span class="line">     source for __ftint86() can be found in the file AINT86.ASM.</span><br /><span class="line"></span><br /><span class="line">     When run in protected mode, this function is a shell for cpmiInt86(),</span><br /><span class="line">     which is written in assembler and makes a DPMI call to drop into</span><br /><span class="line">     real mode and execute the interrupt.  cpmiInt86() is also callable</span><br /><span class="line">     from C, so feel free to incorporate it into any C routines for which</span><br /><span class="line">     it might be useful.  cpmiInt86() is part of the CPMI API.  See the</span><br /><span class="line">     CPMI documentation for more information.</span><br /><span class="line"></span><br /><span class="line"> <span class="ngb">Examples</span></span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">     * This example shows how to call the DOS &#34;create file&#34; service.  Take</span><br /><span class="line">     * special note of how to set up string parameters.</span><br /><span class="line"></span><br /><span class="line">     #include &#34;FTINT86.CH&#34;</span><br /><span class="line"></span><br /><span class="line">     local aRegs[10]              &amp;&amp; Declare the register array</span><br /><span class="line">     aRegs[ AX ] := makehi(60)    &amp;&amp; DOS service, create file</span><br /><span class="line">     aRegs[ CX ] := 0             &amp;&amp; Specify file attribute</span><br /><span class="line"></span><br /><span class="line">     * Pay attention here, this is crucial.  Note how to set up the string</span><br /><span class="line">     * so it appears in DS:DX.</span><br /><span class="line"></span><br /><span class="line">     aRegs[ DS ] := &#34;C:\MISC\MYFILE.XXX&#34;</span><br /><span class="line">     aRegs[ DX ] := REG_DS</span><br /><span class="line">     FT_INT86( 33, aRegs)         &amp;&amp; Make the call to the DOS interrupt</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">     * This example shows how to call the DOS &#34;get current directory&#34;</span><br /><span class="line">     * service.  This one also uses a string parameter, but note that it</span><br /><span class="line">     * uses a different offset register.</span><br /><span class="line"></span><br /><span class="line">     #include &#34;FTINT86.CH&#34;</span><br /><span class="line"></span><br /><span class="line">     local aRegs[10]</span><br /><span class="line">     aRegs[ AX ] := makehi(71)</span><br /><span class="line">     aRegs[ DX ] := 0           // Choose default drive</span><br /><span class="line"></span><br /><span class="line">     * This service requires a 64-byte buffer whose address is in DS:SI.  DOS</span><br /><span class="line">     * will fill the buffer with the current directory.</span><br /><span class="line"></span><br /><span class="line">     aRegs[ DS ] := space(64)</span><br /><span class="line">     aRegs[ SI ] := REG_DS</span><br /><span class="line">     FT_INT86( 33, aRegs)</span><br /><span class="line"></span><br /><span class="line">     ? aRegs[ DS ]       // Display the directory name</span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line"></span><br /><span class="line">     * For the sake of completeness, here&#39;s an example that doesn&#39;t use a</span><br /><span class="line">     * string.  This one changes the video mode.</span><br /><span class="line"></span><br /><span class="line">     #include &#34;FTINT86.CH&#34;</span><br /><span class="line"></span><br /><span class="line">     local aRegs[10]</span><br /><span class="line"></span><br /><span class="line">     aRegs[ AX ] := 16          &amp;&amp; Choose hi-res graphics</span><br /><span class="line">     FT_INT86( 16, aRegs)</span><br /><span class="line"></span><br /><span class="line"> <span class="ngb">Header File:</span> FTINT86.CH</span><br /><span class="line"></span><br /><span class="line"> <span class="ngb">Source:</span> CINT86.C</span><br /><span class="line"></span><br /><span class="line"> <span class="ngb">Author:</span> Ted Means</span><br /></pre>
  
  
  


      </article>

    </section>

  </body>

</html>

