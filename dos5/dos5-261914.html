





<!DOCTYPE html>
<html lang="en">

  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <meta name="generator" content="ng2web v1.5.1 (ngdb v1.2.0)">
    <link rel="stylesheet" type="text/css" href="dos5-style.css">
    <title>DOS 5.0 Ref. » DOS » Structures</title>
    <meta name="description" content="DOS 5.0 Ref.">
    <link rel="prev" href="dos5-261307.html">
    
    
  </head>

  <body>

    <header>
      <nav class="box">
        <ul>
          

<li><a href="../index.html">Guides</a></li>


          

<li><a href="dos5-about.html">About</a></li>


          

<li><a href="dos5-261307.html">Previous</a></li>


          

<li><a href="dos5-221655.html">Up</a></li>


          

<li><span>Next</span></li>


        </ul>
      </nav>
    </header>

    <div id="body">

      
        <nav class="menu box">
          <ul>
              <li>DOS</li>
              <li>
                <ul>
                  <li><a href="index.html">Functions (Int 21h)</a></li>
                  <li><a href="dos5-135422.html">Multiplex (Int 2Fh)</a></li>
                  <li><a href="dos5-159299.html">Interrupts 20h-28h</a></li>
                  <li><a href="dos5-182062.html">Device Driver Fnx</a></li>
                  <li><a href="dos5-221655.html">Structures</a></li>
                  <li><a href="dos5-268064.html">Extended key codes</a></li>
                  
                </ul>
              </li>
          </ul>
        </nav>
      

      <div id="entry" class="box">
        
  
  
    <pre class="entry"><span class="line"></span><br><span class="line">; Miscellaneous DOS I/O macros</span><br><span class="line"></span><br><span class="line">        StdIn  = 0000h</span><br><span class="line">        StdOut = 0001h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">macro DosCall Function</span><br><span class="line">        if Function LT 100h</span><br><span class="line">        mov     ah,Function</span><br><span class="line">        else</span><br><span class="line">        mov     ax,Function</span><br><span class="line">        endif</span><br><span class="line">        int     21h</span><br><span class="line">        endm</span><br><span class="line"></span><br><span class="line">;</span><br><span class="line">; Set character device in binary (&#34;raw&#34;) mode</span><br><span class="line">; - disables recognition of ctrl-c, ctrl-p, ctrl-s, ctrl-z</span><br><span class="line">; - disables DOS&#39;s editing keys during input from StdIn</span><br><span class="line">; Entry : bx = handle of character device (e.g. StdOut)</span><br><span class="line">; Exit  : cf = 1: error on DOS call</span><br><span class="line">;         cf = 0: char. device in binary mode</span><br><span class="line">; Used  : ax,dx,flags</span><br><span class="line">; Note  : Use SetCooked before program termination to</span><br><span class="line">;         restore the I/O mode of a standard device</span><br><span class="line">;         (handle 0..4) to the default ascii mode.</span><br><span class="line">;</span><br><span class="line">macro SetRaw</span><br><span class="line">        local   ahead</span><br><span class="line">        DosCall 4400h           ; Get Device Data (into dx)</span><br><span class="line">        jc      ahead</span><br><span class="line">        or      dl,20h          ; Bit 5 = 1 sets binary mode</span><br><span class="line">        sub     dh,dh           ; Clear bits 8-15</span><br><span class="line">        DosCall 4401h           ; Set Device Data</span><br><span class="line">        ahead:</span><br><span class="line">        endm</span><br><span class="line"></span><br><span class="line">;</span><br><span class="line">; Set character device in ascii (&#34;cooked&#34;) mode</span><br><span class="line">; - enables recognition of ctrl-c, ctrl-p, ctrl-s, ctrl-z</span><br><span class="line">; - enables DOS&#39;s editing keys during input from StdIn</span><br><span class="line">; Entry : bx = handle of character device (e.g. StdIn)</span><br><span class="line">; Exit  : cf = 1: error on DOS call</span><br><span class="line">;         cf = 0: char. device in ascii mode</span><br><span class="line">; Used  : ax,dx,flags</span><br><span class="line">;</span><br><span class="line">macro SetCooked</span><br><span class="line">        local   ahead</span><br><span class="line">        DosCall 4400h           ; Get Device Data (into dx)</span><br><span class="line">        jc      ahead</span><br><span class="line">        and     dx,11011111b    ; Clear bits 5, 8-15</span><br><span class="line">        DosCall 4401h           ; Set Device Data</span><br><span class="line">        ahead:</span><br><span class="line">        endm</span><br><span class="line"></span><br><span class="line">;</span><br><span class="line">; Test redirection of standard input/output</span><br><span class="line">; Entry : Handle = 0 (StdIn) or 1 (StdOut)</span><br><span class="line">; Exit  : cf = 1     Error on DOS call</span><br><span class="line">;         else zf=0  Device is redirected</span><br><span class="line">;              zf=1  Device is not redirected</span><br><span class="line">; Used  : ax,bx,dx,flags</span><br><span class="line">;</span><br><span class="line">macro isDeviceRedirected Handle</span><br><span class="line">        local ahead</span><br><span class="line">        mov     bx,Handle       ; StdIn (Stdout)</span><br><span class="line">        DosCall 4400h           ; Get Device Data (into dx)</span><br><span class="line">        jc      ahead           ; cf set on error</span><br><span class="line">        mov     al,81h + Handle ; 81h (82h)</span><br><span class="line">        and     dl,al           ; Isolate bits 7,0 (7,1)</span><br><span class="line">        cmp     al,dl           ; zf=1 if original device</span><br><span class="line">        ahead:                  ;   attributes, cf=0</span><br><span class="line">        endm</span><br><span class="line"></span><br><span class="line">;</span><br><span class="line">; Has a key been pressed?</span><br><span class="line">; Entry : N/A</span><br><span class="line">; Exit  : zf = 1 if no key available</span><br><span class="line">; Used  : flags</span><br><span class="line">;</span><br><span class="line">macro isKey</span><br><span class="line">        push    ax</span><br><span class="line">        DosCall 0Bh             ; Check StdIn status</span><br><span class="line">        test    al,al</span><br><span class="line">        pop     ax</span><br><span class="line">        endm</span><br><span class="line"></span><br><span class="line">;</span><br><span class="line">; (Wait for and) Read key from keyboard</span><br><span class="line">; Entry : N/A</span><br><span class="line">; Exit  : zf=0: normal key  : ah = 0, al = ASCII code</span><br><span class="line">;         zf=1: extended key: ah = extended code, al = 0</span><br><span class="line">; Used  : ax,flags</span><br><span class="line">; Note  : ax = 0003h if Ctrl-C/Ctrl-Break pressed.</span><br><span class="line">;         Doesn&#39;t display the character read.</span><br><span class="line">;</span><br><span class="line">macro ReadKey</span><br><span class="line">        local ahead</span><br><span class="line">        DosCall 07h             ; Direct console input</span><br><span class="line">        sub     ah,ah</span><br><span class="line">        cmp     al,ah</span><br><span class="line">        jnz     ahead</span><br><span class="line">        DosCall 07h             ; Extended: get 2nd code</span><br><span class="line">        mov     ah,al</span><br><span class="line">        sub     al,al</span><br><span class="line">        ahead:</span><br><span class="line">        endm</span><br><span class="line"></span><br><span class="line">;</span><br><span class="line">; Same as ReadKey, but uses fnx 3fh</span><br><span class="line">; Used  : ax,bx,cx,dx,flags</span><br><span class="line">;</span><br><span class="line">macro ReadKey3F</span><br><span class="line">        local ahead</span><br><span class="line">        push    ds</span><br><span class="line">        mov     bx,StdIn</span><br><span class="line">        SetRaw                  ; Set keyboard in binary mode</span><br><span class="line">        mov     dx,ss</span><br><span class="line">        mov     ds,dx</span><br><span class="line">        push    dx</span><br><span class="line">        mov     dx,sp           ; ds:dx -&gt; 1-byte buffer</span><br><span class="line">        mov     cx,1            ;   on the stack</span><br><span class="line">        DosCall 3fh             ; Read Device</span><br><span class="line">        xchg    bx,dx</span><br><span class="line">        mov     al,[bx]</span><br><span class="line">        xchg    bx,dx</span><br><span class="line">        sub     ah,ah           ; Assume normal key code</span><br><span class="line">        cmp     al,ah</span><br><span class="line">        jnz     ahead</span><br><span class="line">        DosCall 3fh             ; Extended: get 2nd code</span><br><span class="line">        xchg    bx,dx</span><br><span class="line">        mov     ah,[bx]</span><br><span class="line">        xchg    bx,dx</span><br><span class="line">        sub     al,al</span><br><span class="line">        ahead:</span><br><span class="line">        pop     dx              ; Clean up stack</span><br><span class="line">        push    ax              ; Save key pressed</span><br><span class="line">        pushf                   ;   and flags</span><br><span class="line">        SetCooked               ; Restore keyboard</span><br><span class="line">        popf                    ;   to ascii mode</span><br><span class="line">        pop     ax</span><br><span class="line">        pop     ds</span><br><span class="line">        endm</span><br><span class="line"></span><br><span class="line">;</span><br><span class="line">; Read one line from keyboard (StdIn) into memory buffer,</span><br><span class="line">; permitting the use of DOS&#39;s editing keys.</span><br><span class="line">; Entry : ds = segment of Buffer</span><br><span class="line">;         The byte size of Buffer must be &gt;= BufLen</span><br><span class="line">; Exit  : Buffer updated, ax = no. of characters typed</span><br><span class="line">; Used  : ax,bx,cx,dx,flags</span><br><span class="line">; Note  :</span><br><span class="line">;   DOS&#39;s line editor is active during input:</span><br><span class="line">;   - F1..F6, left, right, backspace, ins, del, esc, enter</span><br><span class="line">;     available for editing</span><br><span class="line">;   - responds to ctrl-c, ctrl-p, ctrl-s, ctrl-z</span><br><span class="line">;   - pressing F5 or Esc, or typing more characters than can</span><br><span class="line">;     fit within one line will cause line wrap (scroll down)</span><br><span class="line">;   - pressing Enter completes the function</span><br><span class="line">;   - max. 127 characters can be input</span><br><span class="line">;   Input is echoed to StdOut during editing.</span><br><span class="line">;</span><br><span class="line">;   If BufLen = 0, no input is read. If the no. of characters</span><br><span class="line">;   typed is less than BufLen, a CR/LF pair (a CR character,</span><br><span class="line">;   if one less) is returned as the last byte(s) and included</span><br><span class="line">;   in the count. If the no. of characters typed is equal to</span><br><span class="line">;   or greater than BufLen, AX is returned = BufLen, and the</span><br><span class="line">;   rest of the characters (plus a CR/LF pair) remain in the</span><br><span class="line">;   input and must be removed, for example, by flushing the</span><br><span class="line">;   keyboard.</span><br><span class="line">;         </span><br><span class="line">macro ReadLine Buffer, BufLen</span><br><span class="line">        mov     bx,StdIn</span><br><span class="line">        SetCooked               ; Set keyboard in ascii mode</span><br><span class="line">        lea     dx,[&amp;Buffer]</span><br><span class="line">        mov     cx,BufLen</span><br><span class="line">        DosCall 3Fh             ; Read Device</span><br><span class="line">        endm</span><br><span class="line"></span><br><span class="line">;</span><br><span class="line">; Write one character to StdOut</span><br><span class="line">; Entry : al = character</span><br><span class="line">; Used  : bx,cx,dx,flags</span><br><span class="line">;</span><br><span class="line">macro WriteCh</span><br><span class="line">        push    ds</span><br><span class="line">        push    ax              ; Store character on stack</span><br><span class="line">        mov     dx,ss</span><br><span class="line">        mov     ds,dx</span><br><span class="line">        mov     dx,sp</span><br><span class="line">        mov     cx,1</span><br><span class="line">        mov     bx,StdOut</span><br><span class="line">        DosCall 40h             ; Write to Handle</span><br><span class="line">        pop     ax</span><br><span class="line">        pop     ds</span><br><span class="line">        endm</span><br><span class="line"></span><br><span class="line">;</span><br><span class="line">; Write one CR/LF pair to StdOut</span><br><span class="line">; Entry : N/A</span><br><span class="line">; Used  : al and registers used by WriteCh</span><br><span class="line">;</span><br><span class="line">macro WriteCRLF</span><br><span class="line">        mov     al,0dh</span><br><span class="line">        WriteCh</span><br><span class="line">        mov     al,0ah</span><br><span class="line">        WriteCh</span><br><span class="line">        endm</span><br><span class="line"></span><br><span class="line">;</span><br><span class="line">; Write zero-terminated string to StdOut</span><br><span class="line">; Entry : ds = segment of string (AsciizID)</span><br><span class="line">; Exit  : cx = string length</span><br><span class="line">; Used  : ax,bx,cx,dx,flags</span><br><span class="line">;</span><br><span class="line">        EOS = 00h               ; End-of-string marker</span><br><span class="line">macro WriteZ AsciizID</span><br><span class="line">        local count, done</span><br><span class="line">        lea     dx,[&amp;AsciizID]</span><br><span class="line">        mov     al,EOS</span><br><span class="line">        mov     bx,dx</span><br><span class="line">        dec     bx</span><br><span class="line">        count:</span><br><span class="line">        inc     bx</span><br><span class="line">        cmp     al,[bx]</span><br><span class="line">        jnz     count</span><br><span class="line">        mov     cx,bx</span><br><span class="line">        sub     cx,dx</span><br><span class="line">        jz      done</span><br><span class="line">        mov     bx,StdOut</span><br><span class="line">        DosCall 40h             ; Write to Handle</span><br><span class="line">        done:</span><br><span class="line">        endm</span><br><span class="line"></span><br><span class="line">;</span><br><span class="line">; Convert binary byte value to hex ascii</span><br><span class="line">; Entry : al = binary value</span><br><span class="line">; Exit  : al = low nibble, ah = high nibble</span><br><span class="line">; Used  : ax,flags</span><br><span class="line">;</span><br><span class="line">macro HexB</span><br><span class="line">        mov     ah,al</span><br><span class="line">        if @Cpu and 2</span><br><span class="line">        shr     al,4</span><br><span class="line">        else</span><br><span class="line">        shr     al,1</span><br><span class="line">        shr     al,1</span><br><span class="line">        shr     al,1</span><br><span class="line">        shr     al,1</span><br><span class="line">        endif</span><br><span class="line">        cmp     al,10d          ; Convert to hex ascii</span><br><span class="line">        sbb     al,69h</span><br><span class="line">        das</span><br><span class="line">        xchg    ah,al           ; ah = converted high nibble</span><br><span class="line">        and     al,0fh          ; Repeat for low nibble</span><br><span class="line">        cmp     al,10d</span><br><span class="line">        sbb     al,69h</span><br><span class="line">        das                     ; al = converted low nibble</span><br><span class="line">        endm</span><br><span class="line"></span><br><span class="line">;</span><br><span class="line">; Write binary byte value to StdOut as hex ascii</span><br><span class="line">; Entry : al = binary value</span><br><span class="line">; Used  : ax and registers used by WriteCh</span><br><span class="line">;</span><br><span class="line">macro WriteHexB</span><br><span class="line">        HexB</span><br><span class="line">        push    ax</span><br><span class="line">        mov     al,ah           ; Output high nibble</span><br><span class="line">        WriteCh</span><br><span class="line">        pop     ax              ; Output low nibble</span><br><span class="line">        WriteCh</span><br><span class="line">        endm                                                               <span class="fg1 bg1">Me</span></span><br></pre>
  
  
  
    <nav class="seeAlso">
      <ul>
        <li>See Also:</li>
        
          <li>
            
              <a href="dos5-46090.html">4400h</a>
            
          </li>
        
      </ul>
    </nav>
  


      </div>

    </div>

    
      <footer>
        <nav class="box">
          <dl>
            <dt>Generated</dt><dd>2025-12-13 13:34:39</dd>
            <dt>Generator</dt><dd><a href="https://ng2web.davep.dev">ng2web v1.5.1 (ngdb v1.2.0)</a></dd>
          </dl>
        </nav>
      </footer>
    

  </body>

</html>

