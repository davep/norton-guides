





<!DOCTYPE html>
<html lang="en">

  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <meta name="generator" content="ng2web v1.5.1 (ngdb v1.2.0)">
    <link rel="stylesheet" type="text/css" href="mrdebug-style.css">
    <title>MrDebug for CA-Clipper Ver 1.20.147ß » Reference » Utilities</title>
    <meta name="description" content="MrDebug for CA-Clipper Ver 1.20.147ß">
    
    
    
  </head>

  <body>

    <header>
      <nav class="box">
        <ul>
          

<li><a href="../index.html">Guides</a></li>


          

<li><a href="mrdebug-about.html">About</a></li>


          

<li><span>Previous</span></li>


          

<li><a href="mrdebug-219067.html">Up</a></li>


          

<li><span>Next</span></li>


        </ul>
      </nav>
    </header>

    <div id="body">

      
        <nav class="menu box">
          <ul>
              <li>Reference</li>
              <li>
                <ul>
                  <li><a href="index.html">Menus</a></li>
                  <li><a href="mrdebug-7600.html">Keys</a></li>
                  <li><a href="mrdebug-64852.html">Windows</a></li>
                  <li><a href="mrdebug-123570.html">Mouse Support</a></li>
                  <li><a href="mrdebug-132681.html">The Colour Settings</a></li>
                  <li><a href="mrdebug-137446.html">Index</a></li>
                  <li><a href="mrdebug-167558.html">Tables</a></li>
                  <li><a href="mrdebug-219067.html">Utilities</a></li>
                  
                </ul>
              </li>
              <li>OverView</li>
              <li>
                <ul>
                  <li><a href="mrdebug-232955.html">Introduction</a></li>
                  <li><a href="mrdebug-241082.html">Questions and Answers</a></li>
                  <li><a href="mrdebug-289945.html">Technical Support</a></li>
                  <li><a href="mrdebug-295928.html">Versions</a></li>
                  <li><a href="mrdebug-311206.html">Acknowledgements</a></li>
                  
                </ul>
              </li>
              <li>Tutorial</li>
              <li>
                <ul>
                  <li><a href="mrdebug-317622.html">Getting Started</a></li>
                  <li><a href="mrdebug-329292.html">Working with Source code</a></li>
                  <li><a href="mrdebug-338287.html">Inspecting Variables</a></li>
                  <li><a href="mrdebug-348923.html">Accessing your Database</a></li>
                  <li><a href="mrdebug-354363.html">Using the Profiler</a></li>
                  <li><a href="mrdebug-360448.html">Assertion Checking</a></li>
                  
                </ul>
              </li>
          </ul>
        </nav>
      

      <div id="entry" class="box">
        
  
  
    <pre class="entry"><span class="line"> <span class="ngb">MrDebug.ch</span></span><br><span class="line"> MrDebug header file</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">┌─────────────┬────────────────────────────────────────────────────────────┐</span><br><span class="line">│    File Name│MrDebug.ch                                                  │</span><br><span class="line">│  Description│A few useful things to aid debugging                        │</span><br><span class="line">│ Date created│26-09-94              Date updated: 06-10-94                │</span><br><span class="line">│ Time created│12:12:18pm            Time updated: 10:29:24am              │</span><br><span class="line">│    Copyright│1994 by Dark Black Software Ltd.                            │</span><br><span class="line">└─────────────┴────────────────────────────────────────────────────────────┛</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#ifndef __MRDEBUG_CH</span><br><span class="line">   #define __MRDEBUG_CH</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">┌──────────────────────────────────┐</span><br><span class="line">│ MrDebug Assertion Trace Facility │</span><br><span class="line">├──────────────────────────────────┴────────────────────────────────────┐</span><br><span class="line">│ If you want MrDebug&#39;s Assertion Trace facility to work, then just     │</span><br><span class="line">│ define the MRDEBUG constant when you compile &#39;clipper &lt;x&gt; /dMRDEBUG&#39;, │</span><br><span class="line">│ and the trace commands (below) will show you when your assertions are │</span><br><span class="line">│ failing.                                                              │</span><br><span class="line">└───────────────────────────────────────────────────────────────────────┛</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#ifdef MRDEBUG</span><br><span class="line"></span><br><span class="line">   // Send custom message if condition is not met</span><br><span class="line">   #command TRACE &lt;exp&gt; MESSAGE &lt;list,...&gt;                                 ;</span><br><span class="line">         =&gt; IF !(&lt;exp&gt;)                                                    ;</span><br><span class="line">          ;    MrdTrace (&#34;Trace:&#34;, &lt;list&gt;)                                 ;</span><br><span class="line">          ; ENDIF</span><br><span class="line"></span><br><span class="line">   // Send trace message if condition is not met</span><br><span class="line">   #command TRACE &lt;exp&gt;                                                    ;</span><br><span class="line">         =&gt; IF !(&lt;exp&gt;)                                                    ;</span><br><span class="line">          ;    MrdTrace (&#34;Trace:&#34;, &lt;&#34;exp&#34;&gt;)                                ;</span><br><span class="line">          ; ENDIF</span><br><span class="line"></span><br><span class="line">   // Send implicit trace message</span><br><span class="line">   #command TRACE [MESSAGE &lt;list,...&gt;]                                     ;</span><br><span class="line">         =&gt; MrdTrace (&#34;Trace:&#34;, [&lt;list&gt;])</span><br><span class="line"></span><br><span class="line">   // Send custom message and stop program if condition is not met</span><br><span class="line">   #command ASSERT &lt;exp&gt; MESSAGE &lt;list,...&gt;                                ;</span><br><span class="line">         =&gt; IF !(&lt;exp&gt;)                                                    ;</span><br><span class="line">          ;    MrdAssert (&#34;Assert:&#34;, &lt;list&gt;)                               ;</span><br><span class="line">          ; ENDIF</span><br><span class="line"></span><br><span class="line">   // Send assert message and stop program if condition is not met</span><br><span class="line">   #command ASSERT &lt;exp&gt;                                                   ;</span><br><span class="line">         =&gt; IF !(&lt;exp&gt;)                                                    ;</span><br><span class="line">          ;    MrdAssert (&#34;Assert:&#34;, &lt;&#34;exp&#34;&gt;)                              ;</span><br><span class="line">          ; ENDIF</span><br><span class="line"></span><br><span class="line">   // Send implicit assert message and stop program</span><br><span class="line">   #command ASSERT [MESSAGE &lt;list,...&gt;]                                    ;</span><br><span class="line">         =&gt; MrdAssert (&#34;Assert:&#34;, [&lt;list&gt;])</span><br><span class="line"></span><br><span class="line">   // Check type of variables</span><br><span class="line">   #command ASSERT &lt;var1&gt; AS &lt;type1:STRING,CHARACTER,NUMERIC,FLOAT,INTEGER,;</span><br><span class="line">          ; INT,LOGICAL,DATE,BLOCK,CODEBLOCK,ARRAY,OBJECT,USUAL,ANY&gt;       ;</span><br><span class="line">          ; [, &lt;varN&gt; AS &lt;typeN:STRING,CHARACTER,NUMERIC,FLOAT,INTEGER,INT,;</span><br><span class="line">          ; LOGICAL,DATE,BLOCK,CODEBLOCK,ARRAY,OBJECT,USUAL,ANY&gt;]          ;</span><br><span class="line">         =&gt; MrdVarCheck(.F., {&lt;var1&gt;[, &lt;varN&gt;]},                           ;</span><br><span class="line">          ; {Upper(&lt;&#34;type1&#34;&gt;)[, Upper(&lt;&#34;typeN&#34;&gt;)]},, {&lt;&#34;var1&#34;&gt;[, &lt;&#34;varN&#34;&gt;]})</span><br><span class="line"></span><br><span class="line">   // Function parameter checking</span><br><span class="line">   #command FUNCTION &lt;func&gt;(&lt;var1&gt; &lt;ref1:AS,ASREF&gt; &lt;type1:STRING,CHARACTER,;</span><br><span class="line">          ; NUMERIC,FLOAT,INTEGER,INT,LOGICAL,DATE,BLOCK,CODEBLOCK,ARRAY,  ;</span><br><span class="line">          ; OBJECT,USUAL,ANY&gt;  [, &lt;varN&gt; &lt;refN:AS,ASREF&gt;                   ;</span><br><span class="line">          ; &lt;typeN:STRING,CHARACTER,NUMERIC,FLOAT,INTEGER,INT,LOGICAL,DATE,;</span><br><span class="line">          ; BLOCK,CODEBLOCK,ARRAY,OBJECT,USUAL,ANY&gt; ] )                    ;</span><br><span class="line">          ; [AS &lt;typeX:STRING,CHARACTER,NUMERIC,FLOAT,INTEGER,INT,LOGICAL, ;</span><br><span class="line">          ; DATE,BLOCK,CODEBLOCK,ARRAY,OBJECT,USUAL,ANY&gt;]                  ;</span><br><span class="line">          ; [ &lt;idConvention:CLIPPER, STRICT, PASCAL, CALLBACK&gt; ]           ;</span><br><span class="line">         =&gt; FUNCTION &lt;func&gt;(&lt;var1&gt;[, &lt;varN&gt;])                              ;</span><br><span class="line">          ; LOCAL xMrDebug := MrdVarCheck(.T., {&lt;var1&gt;[, &lt;varN&gt;]},         ;</span><br><span class="line">          ; {Upper(&lt;&#34;type1&#34;&gt;)[, Upper(&lt;&#34;typeN&#34;&gt;)]},                        ;</span><br><span class="line">          ; {(Upper(&lt;&#34;ref1&#34;&gt;) == &#34;ASREF&#34;)[, (Upper(&lt;&#34;refN&#34;&gt;) == &#34;ASREF&#34;)]})</span><br><span class="line"></span><br><span class="line">   // Function parameter checking</span><br><span class="line">   #command STATIC &lt;type:FUNCTION,PROCEDURE&gt; &lt;func&gt;(&lt;var1&gt; &lt;ref1:AS,ASREF&gt; ;</span><br><span class="line">          ; &lt;type1:STRING,CHARACTER,NUMERIC,FLOAT,INTEGER,INT,LOGICAL,DATE,;</span><br><span class="line">          ; BLOCK,CODEBLOCK,ARRAY,OBJECT,USUAL,ANY&gt;                        ;</span><br><span class="line">          ; [, &lt;varN&gt; &lt;refN:AS,ASREF&gt; &lt;typeN:STRING,CHARACTER,NUMERIC,     ;</span><br><span class="line">          ; FLOAT,INTEGER,INT,LOGICAL,DATE,BLOCK,CODEBLOCK,ARRAY,OBJECT,   ;</span><br><span class="line">          ; USUAL,ANY&gt; ] ) [AS &lt;typeX:STRING,CHARACTER,NUMERIC,FLOAT,      ;</span><br><span class="line">          ; INTEGER,INT,LOGICAL,DATE,BLOCK,CODEBLOCK,ARRAY,OBJECT,USUAL,   ;</span><br><span class="line">          ; ANY&gt;] [ &lt;idConvention:CLIPPER, STRICT, PASCAL, CALLBACK&gt; ]     ;</span><br><span class="line">         =&gt; STATIC &lt;type&gt; &lt;func&gt;(&lt;var1&gt;[, &lt;varN&gt;])                         ;</span><br><span class="line">          ; LOCAL xMrDebug := MrdVarCheck(.T., {&lt;var1&gt;[, &lt;varN&gt;]},         ;</span><br><span class="line">          ; {Upper(&lt;&#34;type1&#34;&gt;)[, Upper(&lt;&#34;typeN&#34;&gt;)]},                        ;</span><br><span class="line">          ; {(Upper(&lt;&#34;ref1&#34;&gt;) == &#34;ASREF&#34;)[, (Upper(&lt;&#34;refN&#34;&gt;) == &#34;ASREF&#34;)]})</span><br><span class="line"></span><br><span class="line">   // Function parameter checking</span><br><span class="line">   #command PROCEDURE &lt;func&gt;(&lt;var1&gt; &lt;ref1:AS,ASREF&gt; &lt;type1:STRING,         ;</span><br><span class="line">          ; CHARACTER,NUMERIC,FLOAT,INTEGER,INT,LOGICAL,DATE,BLOCK,        ;</span><br><span class="line">          ; CODEBLOCK,ARRAY,OBJECT,USUAL,ANY&gt; [, &lt;varN&gt; &lt;refN:AS,ASREF&gt;    ;</span><br><span class="line">          ; &lt;typeN:STRING,CHARACTER,NUMERIC,FLOAT,INTEGER,INT,LOGICAL,DATE,;</span><br><span class="line">          ; BLOCK,CODEBLOCK,ARRAY,OBJECT,USUAL,ANY&gt; ] ) [AS &lt;typeX:STRING, ;</span><br><span class="line">          ; CHARACTER,NUMERIC,FLOAT,INTEGER,INT,LOGICAL,DATE,BLOCK,        ;</span><br><span class="line">          ; CODEBLOCK,ARRAY,OBJECT,USUAL,ANY&gt;] [ &lt;idConvention:CLIPPER,    ;</span><br><span class="line">          ; STRICT, PASCAL, CALLBACK&gt; ]                                    ;</span><br><span class="line">         =&gt; PROCEDURE &lt;func&gt;(&lt;var1&gt;[, &lt;varN&gt;])                             ;</span><br><span class="line">          ; LOCAL xMrDebug := MrdVarCheck(.T., {&lt;var1&gt;[, &lt;varN&gt;]},         ;</span><br><span class="line">          ; {Upper(&lt;&#34;type1&#34;&gt;)[, Upper(&lt;&#34;typeN&#34;&gt;)]},                        ;</span><br><span class="line">          ; {(Upper(&lt;&#34;ref1&#34;&gt;) == &#34;ASREF&#34;)[, (Upper(&lt;&#34;refN&#34;&gt;) == &#34;ASREF&#34;)]})</span><br><span class="line"></span><br><span class="line">   #command METHOD FUNCTION &lt;func&gt;(&lt;var1&gt; &lt;ref1:AS,ASREF&gt; &lt;type1:STRING,   ;</span><br><span class="line">          ; CHARACTER,NUMERIC,FLOAT,INTEGER,INT,LOGICAL,DATE,BLOCK,        ;</span><br><span class="line">          ; CODEBLOCK,ARRAY,OBJECT,USUAL,ANY&gt;  [, &lt;varN&gt; &lt;refN:AS,ASREF&gt;   ;</span><br><span class="line">          ; &lt;typeN:STRING,CHARACTER,NUMERIC,FLOAT,INTEGER,INT,LOGICAL,DATE,;</span><br><span class="line">          ; BLOCK,CODEBLOCK,ARRAY,OBJECT,USUAL,ANY&gt; ] ) [AS &lt;typeX:STRING, ;</span><br><span class="line">          ; CHARACTER,NUMERIC,FLOAT,INTEGER,INT,LOGICAL,DATE,BLOCK,        ;</span><br><span class="line">          ; CODEBLOCK,ARRAY,OBJECT,USUAL,ANY&gt;] [ &lt;idConvention:CLIPPER,    ;</span><br><span class="line">          ; STRICT, PASCAL, CALLBACK&gt; ]                                    ;</span><br><span class="line">         =&gt; METHOD FUNCTION &lt;func&gt;(&lt;var1&gt;[, &lt;varN&gt;])                       ;</span><br><span class="line">          ; LOCAL xMrDebug := MrdVarCheck(.T., {&lt;var1&gt;[, &lt;varN&gt;]},         ;</span><br><span class="line">          ; {Upper(&lt;&#34;type1&#34;&gt;)[, Upper(&lt;&#34;typeN&#34;&gt;)]},                        ;</span><br><span class="line">          ; {(Upper(&lt;&#34;ref1&#34;&gt;) == &#34;ASREF&#34;) [, (Upper(&lt;&#34;refN&#34;&gt;) == &#34;ASREF&#34;)]})</span><br><span class="line"></span><br><span class="line">   #command METHOD PROCEDURE &lt;func&gt;(&lt;var1&gt; &lt;ref1:AS,ASREF&gt; &lt;type1:STRING,  ;</span><br><span class="line">          ; CHARACTER,NUMERIC,FLOAT,INTEGER,INT,LOGICAL,DATE,BLOCK,        ;</span><br><span class="line">          ; CODEBLOCK,ARRAY,OBJECT,USUAL,ANY&gt;  [, &lt;varN&gt; &lt;refN:AS,ASREF&gt;   ;</span><br><span class="line">          ; &lt;typeN:STRING,CHARACTER,NUMERIC,FLOAT,INTEGER,INT,LOGICAL,DATE,;</span><br><span class="line">          ; BLOCK,CODEBLOCK,ARRAY,OBJECT,USUAL,ANY&gt; ] ) [AS &lt;typeX:STRING, ;</span><br><span class="line">          ; CHARACTER,NUMERIC,FLOAT,INTEGER,INT,LOGICAL,DATE,BLOCK,        ;</span><br><span class="line">          ; CODEBLOCK,ARRAY,OBJECT,USUAL,ANY&gt;] [ &lt;idConvention:CLIPPER,    ;</span><br><span class="line">          ; STRICT, PASCAL, CALLBACK&gt; ]                                    ;</span><br><span class="line">         =&gt; METHOD FUNCTION &lt;func&gt;(&lt;var1&gt;[, &lt;varN&gt;])                       ;</span><br><span class="line">          ; LOCAL xMrDebug := MrdVarCheck(.T., {&lt;var1&gt;[, &lt;varN&gt;]},         ;</span><br><span class="line">          ; {Upper(&lt;&#34;type1&#34;&gt;)[, Upper(&lt;&#34;typeN&#34;&gt;)]},                        ;</span><br><span class="line">          ; {(Upper(&lt;&#34;ref1&#34;&gt;) == &#34;ASREF&#34;) [, (Upper(&lt;&#34;refN&#34;&gt;) == &#34;ASREF&#34;)]})</span><br><span class="line"></span><br><span class="line">   // Private parameter checking</span><br><span class="line">   #command PARAMETERS &lt;var1&gt; &lt;ref1:AS,ASREF&gt; &lt;type1:STRING,CHARACTER,     ;</span><br><span class="line">          ; NUMERIC,FLOAT,INTEGER,INT,LOGICAL,DATE,BLOCK,CODEBLOCK,ARRAY,  ;</span><br><span class="line">          ; OBJECT,USUAL,ANY&gt; [, &lt;varN&gt; &lt;refN:AS,ASREF&gt; &lt;typeN:STRING,     ;</span><br><span class="line">          ; CHARACTER,NUMERIC,FLOAT,INTEGER,INT,LOGICAL,DATE,BLOCK,        ;</span><br><span class="line">          ; CODEBLOCK,ARRAY,OBJECT,USUAL,ANY&gt; ]                            ;</span><br><span class="line">         =&gt; PARAMETERS &lt;var1&gt;[, &lt;varN&gt;]                                    ;</span><br><span class="line">          ; LOCAL xMrDebug := MrdVarCheck(.T., {m-&gt;&lt;var1&gt;[, m-&gt;&lt;varN&gt;]},   ;</span><br><span class="line">          ; {Upper(&lt;&#34;type1&#34;&gt;)[, Upper(&lt;&#34;typeN&#34;&gt;)]},                        ;</span><br><span class="line">          ; {(Upper(&lt;&#34;ref1&#34;&gt;) == &#34;ASREF&#34;)[, (Upper(&lt;&#34;refN&#34;&gt;) == &#34;ASREF&#34;)]},;</span><br><span class="line">          ; , .T.)</span><br><span class="line"></span><br><span class="line">   #command RETURN &lt;x&gt; AS &lt;type:STRING,CHARACTER,NUMERIC,FLOAT,INTEGER,INT,;</span><br><span class="line">          ; LOGICAL,DATE,BLOCK,CODEBLOCK,ARRAY,OBJECT,USUAL,ANY&gt;           ;</span><br><span class="line">         =&gt; MrdVarCheck (, {&lt;x&gt;}, {Upper(&lt;&#34;type&#34;&gt;)}, {.F.})                ;</span><br><span class="line">          ; RETURN (&lt;x&gt;)</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">   #command TRACE [&lt;exp&gt;] [MESSAGE &lt;list,...&gt;] =&gt;</span><br><span class="line">   #command ASSERT [&lt;exp&gt;] [MESSAGE &lt;list,...&gt;] =&gt;</span><br><span class="line"></span><br><span class="line">   #command FUNCTION &lt;func&gt;(&lt;var1&gt; &lt;ref1:AS,ASREF&gt; &lt;type1&gt; [, &lt;varN&gt;       ;</span><br><span class="line">          ; &lt;refN:AS,ASREF&gt; &lt;typeN&gt; ] ) [AS &lt;typeX&gt;]                       ;</span><br><span class="line">          ; [ &lt;idConvention:CLIPPER, STRICT, PASCAL, CALLBACK&gt; ]           ;</span><br><span class="line">         =&gt; FUNCTION &lt;func&gt;(&lt;var1&gt;[, &lt;varN&gt;])</span><br><span class="line"></span><br><span class="line">   #command PROCEDURE &lt;func&gt;(&lt;var1&gt; &lt;ref1:AS,ASREF&gt; &lt;type1&gt;                ;</span><br><span class="line">          ; [, &lt;varN&gt; &lt;refN:AS,ASREF&gt; &lt;typeN&gt; ] ) [AS &lt;typeX&gt;]             ;</span><br><span class="line">          ; [ &lt;idConvention:CLIPPER, STRICT, PASCAL, CALLBACK&gt; ]           ;</span><br><span class="line">         =&gt; PROCEDURE &lt;func&gt;(&lt;var1&gt;[, &lt;varN&gt;])</span><br><span class="line"></span><br><span class="line">   #command STATIC [&lt;type:PROCEDURE,FUNCTION&gt;] &lt;func&gt;(&lt;var1&gt;               ;</span><br><span class="line">          ; &lt;ref1:AS,ASREF&gt; &lt;type1&gt; [, &lt;varN&gt; &lt;refN:AS,ASREF&gt; &lt;typeN&gt; ] )  ;</span><br><span class="line">          ; [AS &lt;typeX&gt;] [ &lt;idConvention:CLIPPER, STRICT, PASCAL,          ;</span><br><span class="line">          ; CALLBACK&gt; ]                                                    ;</span><br><span class="line">         =&gt; STATIC &lt;type&gt; &lt;func&gt;(&lt;var1&gt;[, &lt;varN&gt;])</span><br><span class="line"></span><br><span class="line">   #command METHOD FUNCTION &lt;func&gt;(&lt;var1&gt; &lt;ref1:AS,ASREF&gt; &lt;type1:STRING,   ;</span><br><span class="line">          ; CHARACTER,NUMERIC,FLOAT,INTEGER,INT,LOGICAL,DATE,BLOCK,        ;</span><br><span class="line">          ; CODEBLOCK,ARRAY,OBJECT,USUAL,ANY&gt;  [, &lt;varN&gt; &lt;refN:AS,ASREF&gt;   ;</span><br><span class="line">          ; &lt;typeN:STRING,CHARACTER,NUMERIC,FLOAT,INTEGER,INT,LOGICAL,DATE,;</span><br><span class="line">          ; BLOCK,CODEBLOCK,ARRAY,OBJECT,USUAL,ANY&gt; ] ) [AS &lt;typeX&gt;]       ;</span><br><span class="line">          ; [ &lt;idConvention:CLIPPER, STRICT, PASCAL, CALLBACK&gt; ]           ;</span><br><span class="line">         =&gt; METHOD FUNCTION &lt;func&gt;(&lt;var1&gt;[, &lt;varN&gt;])</span><br><span class="line"></span><br><span class="line">   #command METHOD PROCEDURE &lt;func&gt;(&lt;var1&gt; &lt;ref1:AS,ASREF&gt; &lt;type1:STRING,  ;</span><br><span class="line">          ; CHARACTER,NUMERIC,FLOAT,INTEGER,INT,LOGICAL,DATE,BLOCK,        ;</span><br><span class="line">          ; CODEBLOCK,ARRAY,OBJECT,USUAL,ANY&gt;  [, &lt;varN&gt; &lt;refN:AS,ASREF&gt;   ;</span><br><span class="line">          ; &lt;typeN:STRING,CHARACTER,NUMERIC,FLOAT,INTEGER,INT,LOGICAL,DATE,;</span><br><span class="line">          ; BLOCK,CODEBLOCK,ARRAY,OBJECT,USUAL,ANY&gt; ] ) [AS &lt;typeX&gt;]       ;</span><br><span class="line">          ; [ &lt;idConvention:CLIPPER, STRICT, PASCAL, CALLBACK&gt; ]           ;</span><br><span class="line">         =&gt; METHOD FUNCTION &lt;func&gt;(&lt;var1&gt;[, &lt;varN&gt;])</span><br><span class="line"></span><br><span class="line">   #command PARAMETERS &lt;var1&gt; &lt;ref1:AS,ASREF&gt; &lt;type1&gt; [, &lt;varN&gt;            ;</span><br><span class="line">          ; &lt;refN:AS,ASREF&gt; &lt;typeN&gt; ]                                      ;</span><br><span class="line">         =&gt; PARAMETERS &lt;var1&gt;[, &lt;varN&gt;]</span><br><span class="line"></span><br><span class="line">   #command RETURN &lt;x&gt; AS &lt;type:STRING,CHARACTER,NUMERIC,FLOAT,INTEGER,INT,;</span><br><span class="line">          ; LOGICAL,DATE,BLOCK,CODEBLOCK,ARRAY,OBJECT,USUAL,ANY&gt;           ;</span><br><span class="line">         =&gt; RETURN (&lt;x&gt;)</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#translate EXPORT LOCAL =&gt;</span><br><span class="line"></span><br><span class="line">// If you like, you can use this syntax too, although nothing</span><br><span class="line">#command LOCAL &lt;var1&gt; AS &lt;type1&gt;[, &lt;varN&gt; AS &lt;typeN&gt;]                      ;</span><br><span class="line">      =&gt; LOCAL &lt;var1&gt;[, &lt;varN&gt;]</span><br><span class="line"></span><br><span class="line">#command STATIC &lt;var1&gt; AS &lt;type1&gt;[, &lt;varN&gt; AS &lt;typeN&gt;]                     ;</span><br><span class="line">      =&gt; STATIC &lt;var1&gt;[, &lt;varN&gt;]</span><br><span class="line"></span><br><span class="line">#command RETURN NIL AS &lt;type:USUAL,ANY&gt;                                    ;</span><br><span class="line">      =&gt; RETURN (NIL)</span><br><span class="line"></span><br><span class="line">#command RETURN NIL AS &lt;type:STRING,CHARACTER,NUMERIC,FLOAT,INTEGER,INT,   ;</span><br><span class="line">       ; LOGICAL,DATE,BLOCK,CODEBLOCK,ARRAY,OBJECT&gt;                        ;</span><br><span class="line">      =&gt; RETURN (NIL)                                                      ;</span><br><span class="line">       ; #error Return value is not &lt;type&gt;</span><br><span class="line"></span><br><span class="line">#command RETURN (&lt;x&gt;) AS &lt;type&gt;                                            ;</span><br><span class="line">      =&gt; RETURN &lt;x&gt; AS &lt;type&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">┌────────────────────────────────┐</span><br><span class="line">│ IF..ENDIF --&gt; DO CASE..ENDCASE │</span><br><span class="line">├────────────────────────────────┴──────────────────────┐</span><br><span class="line">│ These commands map IF statements onto CASE statements │</span><br><span class="line">├───────────────────────────────────────────────────────┴────────────┐</span><br><span class="line">│ The behaviour is the same, but you can trace each branch of a case │</span><br><span class="line">│ statement, and error line numbers are correct                      │</span><br><span class="line">├────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│ Be aware that if you mess up your code construct, then you will    │</span><br><span class="line">│ get a CASE related error and NOT an IF related error               │</span><br><span class="line">├────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│ Oh, and you may find them faster too...                            │</span><br><span class="line">└────────────────────────────────────────────────────────────────────┛</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">   #translate IF(&lt;stuff&gt;,&lt;result1&gt;,&lt;result2&gt;)                              ;</span><br><span class="line">           =&gt; IIF(&lt;stuff&gt;, &lt;result1&gt;, &lt;result2&gt;)</span><br><span class="line"></span><br><span class="line">   #command IF &lt;stuff&gt;                                                     ;</span><br><span class="line">         =&gt; DO CASE; CASE &lt;stuff&gt;</span><br><span class="line"></span><br><span class="line">   #command ELSEIF &lt;stuff&gt;                                                 ;</span><br><span class="line">         =&gt; CASE &lt;stuff&gt;</span><br><span class="line"></span><br><span class="line">   #command ELSE                                                           ;</span><br><span class="line">         =&gt; OTHERWISE</span><br><span class="line"></span><br><span class="line">   #command ENDIF                                                          ;</span><br><span class="line">         =&gt; ENDCASE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">┌────────────────────────────────────────────────────────────────┐</span><br><span class="line">│ MrDump - Constant Definitions                                  │</span><br><span class="line">└────────────────────────────────────────────────────────────────┛</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">   #define MRDUMP_APPEND          1</span><br><span class="line">   #define MRDUMP_ERROR           2</span><br><span class="line">   #define MRDUMP_STACK           4</span><br><span class="line">   #define MRDUMP_VARIABLES       8</span><br><span class="line">   #define MRDUMP_IN_SCOPE       16</span><br><span class="line">   #define MRDUMP_WORKAREAS      32</span><br><span class="line">   #define MRDUMP_SCREEN         64</span><br><span class="line">   #define MRDUMP_MEMORY        128    /* Only applicable with MrDebug */</span><br><span class="line">   #define MRDUMP_SOURCE        256    /* Only applicable with MrDebug */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">┌─────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│ The following portion has been donated by Dave Pearson with thanks from │</span><br><span class="line">│ Dark Black Software Limited                                             │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────────┛</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">╒═════════╤═════════════════════════════════════════════╕</span><br><span class="line">│File Name│ MrDebug.Ch                                  │</span><br><span class="line">│   Author│ David A Pearson                             │</span><br><span class="line">│    Notes│ Constants and commands for use with MrDebug.│</span><br><span class="line">╘═════════╧═════════════════════════════════════════════╛</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   // Parameters for the AltD() function.</span><br><span class="line"></span><br><span class="line">   #define MRD_ALTD_DISABLE      0</span><br><span class="line">   #define MRD_ALTD_ENABLE       1</span><br><span class="line">   #define MRD_ANIMATE           2</span><br><span class="line">   #define MRD_NO_ANIMATE        3</span><br><span class="line">   #define MRD_START_SPEED       4</span><br><span class="line">   #define MRD_STOP_SPEED        5</span><br><span class="line">   #define MRD_VIEW_WORKAREA     6</span><br><span class="line">   #define MRD_START_PROFILE     7</span><br><span class="line">   #define MRD_STOP_PROFILE      8</span><br><span class="line">   #define MRD_CRASH_LOG         9</span><br><span class="line">   #define MRD_REFRESH          10</span><br><span class="line"></span><br><span class="line">   // And, because it can be done, some commands. ;-)</span><br><span class="line"></span><br><span class="line">   #xcommand MRD ANIMATE ON     =&gt; AltD( MRD_ANIMATE )</span><br><span class="line">   #xcommand MRD ANIMATE OFF    =&gt; AltD( MRD_NO_ANIMATE )</span><br><span class="line">   #xcommand MRD SPEED MODE ON  =&gt; AltD( MRD_START_SPEED )</span><br><span class="line">   #xcommand MRD SPEED MODE OFF =&gt; AltD( MRD_STOP_SPEED )</span><br><span class="line">   #xcommand MRD VIEW WORKAREAS =&gt; AltD( MRD_VIEW_WORKAREA )</span><br><span class="line">   #xcommand MRD PROFILE ON     =&gt; AltD( MRD_START_PROFILE )</span><br><span class="line">   #xcommand MRD PROFILE OFF    =&gt; AltD( MRD_STOP_PROFILE )</span><br><span class="line">   #xcommand MRD REFRESH        =&gt; AltD( MRD_REFRESH )</span><br><span class="line"></span><br><span class="line">   // And, a translate function to tell you if MrDebug is linked</span><br><span class="line">   // in or not.</span><br><span class="line"></span><br><span class="line">   #xtranslate IsMrDebug()      =&gt; If( AltD( 42 ) == NIL, .F., .T. )</span><br><span class="line"></span><br><span class="line">   // Now, one for your ErrorSys. It&#39;s a command to make a call to</span><br><span class="line">   // MrdSaveErr() and save your error object only if MrDebug is</span><br><span class="line">   // linked into your application. This means that your general</span><br><span class="line">   // error system in your super cool library can talk to MrDebug</span><br><span class="line">   // if it&#39;s there, and that the linker won&#39;t moan that it can&#39;t</span><br><span class="line">   // find MrdSaveErr when it ain&#39;t there.</span><br><span class="line">   //</span><br><span class="line">   // The only downside to this solution is that we need to do a</span><br><span class="line">   // macro compile, but, what the hell eh, it&#39;s worth it if it&#39;s</span><br><span class="line">   // for MrDebug! ;-)</span><br><span class="line"></span><br><span class="line">   #xcommand MRD SAVE ERROR &lt;oError&gt;                            ;</span><br><span class="line">             =&gt;                                                 ;</span><br><span class="line">             If IsMrDebug()                                    ;;</span><br><span class="line">                eval( &amp;( &#34;{|o| MrdSaveErr( o ) }&#34; ), &lt;oError&gt; );;</span><br><span class="line">             EndIf</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre>
  
  
  


      </div>

    </div>

    
      <footer>
        <nav class="box">
          <dl>
            <dt>Generated</dt><dd>2025-12-13 13:34:45</dd>
            <dt>Generator</dt><dd><a href="https://ng2web.davep.dev">ng2web v1.5.1 (ngdb v1.2.0)</a></dd>
          </dl>
        </nav>
      </footer>
    

  </body>

</html>

